<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构_9--查找 | memorygo's blog</title><meta name="author" content="tzw"><meta name="copyright" content="tzw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="查找基本概念 123456查找 ——在数据集合中寻找满足某种条件的数据元素的过程查找表 —— 查找数据的集合，由同一类型的数据元素组成（任意数据结构）关键字 —— 数据元素中唯一表示该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。     静态查找表  12只需要查找，重点关注查找速度     动态查找表  12需要查找，还要 插入&#x2F;删除都需要考虑     查找算法的评价指标">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构_9--查找">
<meta property="og:url" content="http://example.com/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9--%E6%9F%A5%E6%89%BE/index.html">
<meta property="og:site_name" content="memorygo&#39;s blog">
<meta property="og:description" content="查找基本概念 123456查找 ——在数据集合中寻找满足某种条件的数据元素的过程查找表 —— 查找数据的集合，由同一类型的数据元素组成（任意数据结构）关键字 —— 数据元素中唯一表示该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。     静态查找表  12只需要查找，重点关注查找速度     动态查找表  12需要查找，还要 插入&#x2F;删除都需要考虑     查找算法的评价指标">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png">
<meta property="article:published_time" content="2024-12-18T08:33:56.000Z">
<meta property="article:modified_time" content="2024-12-18T08:34:00.881Z">
<meta property="article:author" content="tzw">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9--%E6%9F%A5%E6%89%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构_9--查找',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-18 16:34:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="memorygo's blog"><span class="site-name">memorygo's blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构_9--查找</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-12-18T08:33:56.000Z" title="Created 2024-12-18 16:33:56">2024-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-12-18T08:34:00.881Z" title="Updated 2024-12-18 16:34:00">2024-12-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构_9--查找"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">查找 ——在数据集合中寻找满足某种条件的数据元素的过程</span><br><span class="line"></span><br><span class="line">查找表 —— 查找数据的集合，由同一类型的数据元素组成（任意数据结构）</span><br><span class="line"></span><br><span class="line">关键字 —— 数据元素中唯一表示该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/673ec79dd29ded1a8cb4a29d.png"><img src="https://pic.imgdb.cn/item/673ec79dd29ded1a8cb4a29d.png"></a> </p>
<ul>
<li>静态查找表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只需要查找，</span><br><span class="line">重点关注查找速度</span><br></pre></td></tr></table></figure>



<ul>
<li>动态查找表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要查找，还要 插入/删除</span><br><span class="line">都需要考虑</span><br></pre></td></tr></table></figure>



<ul>
<li>查找算法的评价指标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">查找长度 —— 在查找中，需要对比关键字的次数</span><br><span class="line"></span><br><span class="line">平均查找长度 —— 所有查找过程中进行关键字的比较次数的平均值</span><br><span class="line">【ASL，Average Search Length】</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ASL 的数量级反应了 查找算法的时间复杂度</span><br><span class="line"></span><br><span class="line">查找算法效率评价：</span><br><span class="line">- 查找成功 的ASL</span><br><span class="line">- 查找失败 的ASL</span><br></pre></td></tr></table></figure>



<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">顺序查找，又称“线性查找”，通常用于线性表(顺序表，链表)</span><br><span class="line"></span><br><span class="line">算法思想是：从头到脚挨个查找（相反也行）</span><br></pre></td></tr></table></figure>



<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for循环</span><br><span class="line"></span><br><span class="line"># 将要查找的值存储到查找表的0号位，可以少判断一个条件，返回0代表查找失败</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/673ecc2cd29ded1a8cb7ef6a.png"><img src="https://pic.imgdb.cn/item/673ecc2cd29ded1a8cb7ef6a.png"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查找失败的情况只有一种：遍历对比到0号位</span><br><span class="line">该情况 对比关键字 n+1次 。</span><br></pre></td></tr></table></figure>



<h3 id="时间为O-n"><a href="#时间为O-n" class="headerlink" title="时间为O(n)"></a>时间为O(n)</h3><h4 id="有序表优化"><a href="#有序表优化" class="headerlink" title="有序表优化"></a>有序表优化</h4><p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/673ece47d29ded1a8cb9dcb8.png"><img src="https://pic.imgdb.cn/item/673ece47d29ded1a8cb9dcb8.png"></a> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当查找值在有序表中对比时，遇到比它还大的元素时，代表查找失败</span><br><span class="line"></span><br><span class="line">此时查找 失败 的情况有 n + 1 种</span><br><span class="line">ASL失败 = 1/n+1 + 2/n+1 + ... + n/n+1 + n/n+1</span><br><span class="line"></span><br><span class="line"># 最后一个情况，不用算入对比次数，因为0号位本来就是查找元素，不需要自己比较自己。</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查找长度 —— 在查找中，需要对比关键字的次数</span><br><span class="line"></span><br><span class="line">查找失败结点，只是判断了查找元素小于失败结点，并没有进行对比。</span><br><span class="line"></span><br><span class="line">(查找判断树，判定ASL)</span><br><span class="line">成功结点的查找长度 = 自身层数</span><br><span class="line">失败结点的查找长度 = 其父结点所在层数</span><br><span class="line">默认情况下，失败/成功情况等概率发生</span><br></pre></td></tr></table></figure>



<h4 id="被查概率不相等"><a href="#被查概率不相等" class="headerlink" title="被查概率不相等"></a>被查概率不相等</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将被查概率大的放在靠前位置</span><br><span class="line">ASL成功 会变小  （得到优化）</span><br><span class="line"></span><br><span class="line">但是 ASL失败 依然 是 n+1 (不会优化)</span><br></pre></td></tr></table></figure>



<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">又称“二分查找”，仅适用于”有序的顺序表“</span><br><span class="line"></span><br><span class="line"># 不是遍历，所以不需要 哨兵</span><br><span class="line"># 链表不具有 随机访问的特性，需要根据指针一个个访问。不适用</span><br></pre></td></tr></table></figure>



<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">设置low指针和high指针分别指向查找表尾和表头</span><br><span class="line">mid = (low + high)/2</span><br><span class="line"></span><br><span class="line">若mid小于查找值，说明要查找的元素可能在mid右边，此时</span><br><span class="line">low = mid + 1</span><br><span class="line">若mid大于查找值，说明要查找的元素可能在mid左边，此时</span><br><span class="line">high = mid -1</span><br><span class="line"></span><br><span class="line">一直循环，若最后 high = low = 查找元素 (= mid) 则成功找到</span><br><span class="line">若最后 low &gt; high 则查找失败</span><br><span class="line"></span><br><span class="line">每次对比 查找 元素时，都是用mid对比 (计算查找长度-&gt;ASL)</span><br><span class="line">循环过程：</span><br><span class="line">- mid 对比 	( == )</span><br><span class="line">- mid 大小 比较		-- &gt; 移动 low 和 high ( &lt; , &gt; )</span><br></pre></td></tr></table></figure>



<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//定义顺序表</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	ElemType *elem ;</span><br><span class="line">	int TableLen ; </span><br><span class="line">&#125;SSTable ;</span><br><span class="line"></span><br><span class="line">int Binary_Search(SSTable L,ElemType key)&#123;</span><br><span class="line">	int low = 0 , high = L.TableLen - 1 , mid;</span><br><span class="line">	while(low &lt;= high)&#123;</span><br><span class="line">		mid = (low + high)/2;</span><br><span class="line">		if(L.elem[mid] == key)</span><br><span class="line">			return mid;</span><br><span class="line">		else if(L.elem[mid] &gt; key)&#123;</span><br><span class="line">			high = mid - 1;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			low = mid +1 ;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;				//查找失败，返回 -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="算法效率分析"><a href="#算法效率分析" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><ul>
<li><code>折半查找判定树</code>构造</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mid 为父结点，mid左边为左子树，mid右边为右子树</span><br><span class="line">根据此原则，可构建 折半查找 判定树</span><br><span class="line"></span><br><span class="line">- low和high 之间 有奇数个元素，mid分隔后，左右元素个数相等</span><br><span class="line">- low 和 high 之间 有偶数个元素，mid分隔后，左比右少一个</span><br><span class="line"></span><br><span class="line">#左子树只会比右子树少一个结点</span><br><span class="line">(故 不均时 左为 NULL ，右 有 一个)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">满足二叉排序树 的定义</span><br><span class="line">失败结点 n+1个 成功结点的空指针数目</span><br></pre></td></tr></table></figure>

<p><code>折半查找的判断树一定是平衡二叉树，树高为log_2 (n+1)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ASL成功 = </span><br><span class="line">ASL失败 = </span><br></pre></td></tr></table></figure>



<ul>
<li>时间复杂度</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(log_2 n)</span><br></pre></td></tr></table></figure>





<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/674147bed29ded1a8c93207d.png"><img src="https://pic.imgdb.cn/item/674147bed29ded1a8c93207d.png"></a></p>
<p>算法思想：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">定义：</span><br><span class="line">索引表中存储各个分块，分块存储了存储区间，以及区间内最大的关键字</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line">块内无序，块间有序</span><br><span class="line"></span><br><span class="line">查找过程：</span><br><span class="line">1. 索引表中确定查找数据的所属分块(可顺序，折半)</span><br><span class="line">2. 块内顺序查找</span><br></pre></td></tr></table></figure>





<p>代码定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//索引表</span><br><span class="line">typedef struct &#123;</span><br><span class="line">	ElemType maxValue;</span><br><span class="line">	int low,high;</span><br><span class="line">&#125;Index;</span><br><span class="line"></span><br><span class="line">ElemType List[100];</span><br></pre></td></tr></table></figure>



<ul>
<li>折半查找索引</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">low指向最小块，high指向最大块</span><br><span class="line">进行折半查找数据，</span><br><span class="line">最终若low&gt;high,则直接在low所指向分块中查找</span><br><span class="line">若low = high ,则在 mid/low/high 分块中查找</span><br></pre></td></tr></table></figure>



<ul>
<li>算法效率分析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ASL= </span><br><span class="line">查找成功复杂</span><br><span class="line">查找失败更复杂</span><br><span class="line"></span><br><span class="line">长度为n的查找表被均匀地分为b块，每块s个元素</span><br><span class="line">其平均查找长度：ASL = </span><br></pre></td></tr></table></figure>





<h2 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也称 二叉查找树（Binary Search Tree)</span><br></pre></td></tr></table></figure>



<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左子树结点值 &lt; 根结点值 &lt; 右子树结点值</span><br></pre></td></tr></table></figure>

<ul>
<li><code>对二叉排序树进行中序遍历，可以得到一个递增的有序序列</code></li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><ul>
<li>查找过程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">小于根结点，往左子树找，</span><br><span class="line">大于根结点，往右子树找，</span><br><span class="line">查找成功 返回结点指针</span><br><span class="line">查找失败，返回null</span><br></pre></td></tr></table></figure>



<ul>
<li>代码实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BSTNode&#123;</span><br><span class="line">	int key;</span><br><span class="line">	struct BSTNode *lchild,*rchild;</span><br><span class="line">&#125;BSTNode,*BSTree</span><br><span class="line"></span><br><span class="line">//直接遍历(循环，非递归),空间复杂度O(1)</span><br><span class="line">BSTNode *BST_Search(BSTree T,int key)&#123;</span><br><span class="line">	while(T!=NULL&amp;&amp;key!=T-&gt;key)&#123;</span><br><span class="line">		if(key&lt;T-&gt;key) T=T-&gt;lchild;</span><br><span class="line">		else	T = T-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//递归遍历,空间复杂度O(h)</span><br><span class="line">BSTNode *BSTSearch(BSTree T,int key)&#123;</span><br><span class="line">	if(T==NULL||T-&gt;key==key)</span><br><span class="line">		return T;</span><br><span class="line">	if(key&lt;T-&gt;key)</span><br><span class="line">		return BSTSearch(T-&gt;lchild,key);</span><br><span class="line">	else</span><br><span class="line">		return BSTSearch(T-&gt;rchild,key);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//递归插入</span><br><span class="line">int BST_Insert(BSTree &amp;T,int k)&#123;</span><br><span class="line">	if(T==NULL)&#123;</span><br><span class="line">		T = (BSTree)malloc(sizeof(BSTNode));</span><br><span class="line">		T-&gt;key = k;</span><br><span class="line">		T-&gt;lchild = T-&gt;rchild = NULL;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(T-&gt;key==k)&#123;</span><br><span class="line">		return 0; 	//存在相同值，插入失败</span><br><span class="line">	&#125;</span><br><span class="line">	if(T-&gt;key &lt; k)</span><br><span class="line">		return BST_Insert(T-&gt;rchild,k);</span><br><span class="line">	</span><br><span class="line">	else</span><br><span class="line">		return BST_Insert(T-&gt;lchild,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//循环插入 ？？？有误！！！！！！！！！！！</span><br><span class="line">int BSTInsert(BSTree &amp;T,int k)&#123;</span><br><span class="line">	while(T!=NULL&amp;&amp;T-&gt;key!=k)&#123;</span><br><span class="line">		T = T-&gt;lchild;</span><br><span class="line">		T = T-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">	if(T==NULL)&#123;</span><br><span class="line">		T = (BSTree)malloc(sizeof(BSTNOde));</span><br><span class="line">		T-&gt;key = k;</span><br><span class="line">		T-&gt;lchild = NULL;</span><br><span class="line">		T-&gt;rchild = NULL;</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(T-&gt;key == k)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构造操作"><a href="#构造操作" class="headerlink" title="构造操作"></a>构造操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//按照序列str[],建立二叉排序树</span><br><span class="line">void Creat_BST(BSTree &amp;T,int str[],int n)&#123;</span><br><span class="line">	T = NULL;</span><br><span class="line">	int i=0;</span><br><span class="line">	while(i&lt;n)&#123;</span><br><span class="line">		BST_Insert(T,str[i]);</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">删除目标结点(三种方式)：</span><br><span class="line">- 目标是叶子结点，直接删除</span><br><span class="line"></span><br><span class="line">- 若目标只有一棵子树，删除后，让其父结点连接那唯一的子树</span><br><span class="line"></span><br><span class="line">- 目标有左右两棵子树，从右子树中找最小结点，将其值填充在目标位置，然后再删除这个 最小结点 ---(此结点一定没有左子树，用方式二删除)</span><br><span class="line">（用左子树中最大结点，亦然）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[方式三本质是用填充目标结点，再用方式二删除用来填充的结点]</span><br></pre></td></tr></table></figure>







<h2 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">简称平衡树(AVL,Adelson-Velsky 和 Landis 发明)</span><br><span class="line">-- 树上任一结点的左右子树高度差不超过1</span><br><span class="line"></span><br><span class="line">结点平衡因子 = 左子树高 - 子树高度</span><br><span class="line">[只可能是0,-1,1]</span><br></pre></td></tr></table></figure>



<p>代码定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct AVLNode&#123;</span><br><span class="line">	int key;</span><br><span class="line">	int balance;</span><br><span class="line">	struct AVLNode *lchild , *rchild;</span><br><span class="line">&#125;AVLNode,*AVLTree;</span><br></pre></td></tr></table></figure>



<h3 id="插入操作-1"><a href="#插入操作-1" class="headerlink" title="插入操作"></a>插入操作</h3><h4 id="调整最小不平衡子树"><a href="#调整最小不平衡子树" class="headerlink" title="调整最小不平衡子树"></a>调整最小不平衡子树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在插入一个结点到”平衡二叉排序树“时，我们可能导致该平衡树不平衡，</span><br><span class="line">此时 我们需要通过 找到并调整最小不平衡子树 去解决不平衡问题</span><br><span class="line"></span><br><span class="line">最小不平衡子树 :</span><br><span class="line">此时A根结点为平衡因子最先发生改变的结点</span><br></pre></td></tr></table></figure>

<ul>
<li>目标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 恢复平衡</span><br><span class="line">2. 保持二叉排序树特性</span><br></pre></td></tr></table></figure>



<ul>
<li>LL</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/674181ded29ded1a8ccebfe7.png"><img src="https://pic.imgdb.cn/item/674181ded29ded1a8ccebfe7.png"></a> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(即A-&gt;lchild-&gt;lchild,在BL上插入数据)</span><br><span class="line">实现LL右旋：</span><br><span class="line">- A左孩子B，成为A的父结点，A成为B的右孩子</span><br><span class="line">- B的原右孩子BR成为到A的左孩子</span><br><span class="line"></span><br><span class="line">AB辈分互换，保持左根右排序</span><br></pre></td></tr></table></figure>



<ul>
<li>RR</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/67418290d29ded1a8ccf5031.png"><img src="https://pic.imgdb.cn/item/67418290d29ded1a8ccf5031.png"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">实现RR左旋：</span><br><span class="line">- A右孩子B，成为A的父结点，A成为B的左孩子</span><br><span class="line">- B的原左孩子BR成为到A的右孩子</span><br><span class="line"></span><br><span class="line">AB辈分互换，保持左根右排序</span><br></pre></td></tr></table></figure>



<ul>
<li>LR</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/674183d9d29ded1a8cd06484.png"><img src="https://pic.imgdb.cn/item/674183d9d29ded1a8cd06484.png"></a> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C升辈，B降辈，保持排序</span><br><span class="line">（CB辈分互换）</span><br><span class="line">C升辈，A降辈，，保持排序</span><br><span class="line">（CA辈分互换）</span><br></pre></td></tr></table></figure>



<ul>
<li>RL</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/67418413d29ded1a8cd0907f.png"><img src="https://pic.imgdb.cn/item/67418413d29ded1a8cd0907f.png"></a></p>
<h3 id="删除操作-1"><a href="#删除操作-1" class="headerlink" title="删除操作"></a>删除操作</h3><ul>
<li>目标</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 恢复平衡</span><br><span class="line">2. 保持二叉排序树特性</span><br></pre></td></tr></table></figure>



<ul>
<li>具体操作</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 二叉排序树删除结点操作</span><br><span class="line">2. 向上找最小不平衡子树，找不到代表删除完成</span><br><span class="line">3. 找到最小不平衡子树下，“个头”最高的儿子，孙子</span><br><span class="line">4. 根据孙子的位置，调整平衡(LL/RR/LR/RL)</span><br><span class="line">5. 如果不平衡向上传导，回到2，继续循环</span><br></pre></td></tr></table></figure>

<ul>
<li>不平衡未传导</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/6741873fd29ded1a8cd31e9e.png"><img src="https://pic.imgdb.cn/item/6741873fd29ded1a8cd31e9e.png"></a> </p>
<ul>
<li>不平衡向上传导</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/67418825d29ded1a8cd3e88f.png"><img src="https://pic.imgdb.cn/item/67418825d29ded1a8cd3e88f.png"></a> </p>
<h2 id="红黑树（RBT"><a href="#红黑树（RBT" class="headerlink" title="红黑树（RBT)"></a>红黑树（RBT)</h2><h3 id="来源与特性"><a href="#来源与特性" class="headerlink" title="来源与特性"></a>来源与特性</h3><p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/67418aa2d29ded1a8cd5f87b.png"><img src="https://pic.imgdb.cn/item/67418aa2d29ded1a8cd5f87b.png"></a> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Red-Black Tree  ---RBT</span><br><span class="line">各操作的时间复杂度和AVL一致，什么要发明红黑树？</span><br></pre></td></tr></table></figure>



<p><code>平衡二叉树 AVL:</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">插入/删除很容易破坏”平衡“特性，需要频繁调整树都形态，如：插入操作导致不平衡，需要先计算平衡因子，找到最小不平衡子树，再进行LL/RR/LR/RL调整。</span><br><span class="line">(时间开销较大)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">:适用于以查为主，很少插入/删除的场景</span><br></pre></td></tr></table></figure>



<p><code>红黑树 RBT:</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">插入/删除 很多时候不会破坏&quot;红黑&quot;特性，无需频繁调整树的形态。即便需要调整，一遍可以在常数级时间内完成。</span><br><span class="line"></span><br><span class="line">:适用于频繁插入，删除场景，实用性更强(ps:工程现在基本都采用红黑树，而不是AVL) </span><br></pre></td></tr></table></figure>



<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">红黑树，是一种特殊的二叉排序树</span><br><span class="line">：左子树结点值&lt;根结点值&lt;右子树结点值</span><br></pre></td></tr></table></figure>



<p><code>与普通BST相比</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 每个结点或是红色，或是黑色</span><br><span class="line">- 根结点是黑色的</span><br><span class="line">- 叶结点均是黑色(此叶结点特指NULL结点)</span><br><span class="line">- 不存在两个相邻连接的红结点(红结点的父结点和孩子结点均是黑色)</span><br><span class="line">- 对每个结点，从该结点到任一叶结点的简单路径上，经过的黑结点数目相同**</span><br></pre></td></tr></table></figure>

<ul>
<li>结点的黑高</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从某结点出发(不包含该结点)到达任意叶结点的路径上黑结点总数</span><br></pre></td></tr></table></figure>

<ul>
<li>叶节点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">叶子结点：度为0</span><br><span class="line">即，分支数为0，</span><br><span class="line">NULL也是子树分支，为空子树，所以叶子结点必须为NULL</span><br><span class="line"></span><br><span class="line">RBT的叶结点，也是失败结点，外部结点，NULL结点，空结点</span><br></pre></td></tr></table></figure>





<ul>
<li>代码定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct RBnode&#123;</span><br><span class="line">	int key ;			//关键字的值</span><br><span class="line">	RBnode *parent;</span><br><span class="line">	RBnode *lchild;</span><br><span class="line">	RBnode *rchild;</span><br><span class="line">	int color;		//结点颜色，可用0/1表示红黑，也可用枚举型enum表示颜色 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与BST，AVL一样，从根出发，左下右大，若查到一个空叶结点，则查找失败</span><br></pre></td></tr></table></figure>



<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/6746d4bfd0e0a243d4d1e934.png"><img src="https://pic.imgdb.cn/item/6746d4bfd0e0a243d4d1e934.png" alt="item.filename"></a> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左根右，根叶黑，不红红，黑路同</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">查找，确定插入位置，插入新结点		（确保左根右）</span><br><span class="line">- 新结点为根 —— 染黑	（确保根叶黑，叶结点就是NULL，虚拟、空结点）</span><br><span class="line">- 新结点为非根 —— 染红	（确保黑路同）</span><br><span class="line">	- 满足红黑树，结束退出</span><br><span class="line">	- 不满足红黑树，调整进行		（确保不红红）</span><br><span class="line">		- 看插入结点的叔叔。</span><br><span class="line">			叔黑：LL,RR，LR，RL，</span><br><span class="line">			</span><br><span class="line">LL</span><br><span class="line">- 插入的结点的爷结点变为父结点的右孩子（父换爷：父升辈分，爷降辈分）</span><br><span class="line">- 染色：黑染成红，红染成黑。		让父爷结点染色</span><br><span class="line">	</span><br><span class="line">LR</span><br><span class="line">- 左右双旋，先升辈到父，保持左根右，再升辈到爷，(辈分互换两次)</span><br><span class="line">最后原来 儿、爷 进行染色</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			叔红：染色 + 变新</span><br><span class="line">- 插入结点的 叔 父 爷 染色，爷结点作为新插入的结点，再次进行相应措施</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 有n个内部结点的红黑树高度h&lt;=2log(n+1)</span><br><span class="line">- 从根结点到叶结点的最长路径不大于最短路径的2倍</span><br><span class="line"></span><br><span class="line">RBT左右子树高度差，不超过较短路径的2倍。不容易被破坏，不需要频繁去调整</span><br><span class="line">AVL左右子树高度差，不超过1。容易被破坏，频繁去调整</span><br></pre></td></tr></table></figure>



<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/674804a6d0e0a243d4d89e39.png"><img src="https://pic.imgdb.cn/item/674804a6d0e0a243d4d89e39.png" alt="item.filename"></a> </p>
<h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据结构难点</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//5叉排序树</span><br><span class="line">struct Node &#123;</span><br><span class="line">	ElemType keys[4];		//最多4个关键字</span><br><span class="line">	struct Node * child[5];	//最多5个孩子</span><br><span class="line">	int num;		//关键字的数目</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个结点内可以使用折半查找</p>
<h3 id="保证查找效率"><a href="#保证查找效率" class="headerlink" title="保证查找效率"></a>保证查找效率</h3><ul>
<li>策略1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m叉查找树中，规定除了根结点外，任何结点至少有[m/2]个分叉，即至少含有[m/2]-1个关键字</span><br><span class="line"></span><br><span class="line"># 此处[]代表向上取整</span><br></pre></td></tr></table></figure>



<ul>
<li>策略2：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 散列查找</span><br><span class="line"></span><br><span class="line">### 哈希表、散列表</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Hash Table(散列表)，又称哈希表，一种数据结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>特点：数据元素的关键字与其存储地址直接相关</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 建立”关键字“与”存储地址“的联系</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过哈希函数（散列函数）：Addr &#x3D; H(key)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 哈希映射</span><br><span class="line"></span><br><span class="line">`建立”关键字“与”存储地址“的联系`</span><br><span class="line"></span><br><span class="line">[![item.filename](https://pic.imgdb.cn/item/67480690d0e0a243d4d8a9dd.png)](https://pic.imgdb.cn/item/67480690d0e0a243d4d8a9dd.png) </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同义词：不同关键字通过哈希函数映射到同一个值<br>冲突：哈希函数确定的位置已经存放了其他元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 拉链法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>又称 链接法、链地址法<br>解决冲突的方法之一 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[![item.filename](https://pic.imgdb.cn/item/674807bad0e0a243d4d8b015.png)](https://pic.imgdb.cn/item/674807bad0e0a243d4d8b015.png) </span><br><span class="line"></span><br><span class="line">- 重点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>把同义词存储到一个链表中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 开放定址法</span><br><span class="line"></span><br><span class="line">##### 线性探测法</span><br><span class="line"></span><br><span class="line">发生冲突时，每次往后探测相邻的下一个单元是否为空</span><br><span class="line"></span><br><span class="line">$H_i = (H(key) + d_i) \% m$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m为散列表长，di为增量序列(0,1,2,3,4......)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>缺点：容易造成堆积现象，严重影响查找效率</p>
<p>冲突后会往后探测一个连续的位置，可能都不为空，会一直向后探测，影响效率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 平方探测法</span><br><span class="line"></span><br><span class="line">又称二次探测法</span><br><span class="line"></span><br><span class="line">di增量序列为</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>0,1,-1,4,-4,9,-9,16,-16……</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 再散列法</span><br><span class="line"></span><br><span class="line">多准备几个散列函数,当产生冲突时，使用下一个散列函数再散列，计算新地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 伪随机序列法</span><br><span class="line"></span><br><span class="line">di增量序列为</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>某个伪随机序列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 散列查找</span><br><span class="line"></span><br><span class="line">#### 核心思想</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>空间换时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从 **查找目标** 经过 哈希函数 **映射的位置**，进行遍历查找</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查找长度 ：在查找运算中，需要对比关键字的次数<br>（有的教材有其他的定义）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**为了提高查找效率，我们需要设计冲突少的哈希函数**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 装填因子</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>表中记录数&#x2F;散列表长度</p>
<p>反映 散列表的查找效率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 常见的哈希函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 取模法</span><br><span class="line"></span><br><span class="line">​     $H(key) = key\ \% \  p$  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>散列表 表长为m，<br>取一个不大于m但最接近或等于m的质数p</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>质数，又称素数，指出了1和此整数自身外，不能被其他自然数整除的数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">用质数取模，分布更均匀，冲突更少。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不适合关键字基本连续</p>
<p>当关键字成偶数出现，会更均匀</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 直接定址法 </span><br><span class="line"></span><br><span class="line">   $H(key) = key $  或 $H(key) = a*key + b$</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">优点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不会产生冲突，适合关键字的分布基本连续情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">缺点</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关键字分布的空位较多，会造成存储空间较多的浪费</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 数字分析法</span><br><span class="line"></span><br><span class="line">选取数码分布较为均匀的若干位作为散列地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>比如将手机号后4位作为散列地址，存储手机号</p>
<pre><code>


- 平方取中法

取关键字的平方值的中间几位作为散列地址






</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">tzw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9--%E6%9F%A5%E6%89%BE/">http://example.com/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9--%E6%9F%A5%E6%89%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_8--%E5%9B%BE/" title="数据结构_8--图"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">数据结构_8--图</div></div></a></div><div class="next-post pull-right"><a href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_T1--%E5%BC%95%E5%AD%90/" title="数据结构_T1--引子"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">数据结构_T1--引子</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">tzw</div><div class="author-info__description">this is memorygo's house</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/memorygo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">1.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.</span> <span class="toc-text">顺序查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">1.2.1.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E4%B8%BAO-n"><span class="toc-number">1.2.3.</span> <span class="toc-text">时间为O(n)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">有序表优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A2%AB%E6%9F%A5%E6%A6%82%E7%8E%87%E4%B8%8D%E7%9B%B8%E7%AD%89"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">被查概率不相等</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">1.3.</span> <span class="toc-text">折半查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E6%83%B3"><span class="toc-number">1.3.1.</span> <span class="toc-text">思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.3.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="toc-number">1.3.3.</span> <span class="toc-text">算法效率分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="toc-number">1.4.</span> <span class="toc-text">分块查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="toc-number">1.5.</span> <span class="toc-text">二叉排序树（BST）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.5.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.3.</span> <span class="toc-text">查找操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.4.</span> <span class="toc-text">插入操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.5.</span> <span class="toc-text">构造操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.6.</span> <span class="toc-text">删除操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">平衡二叉树（AVL）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.6.1.</span> <span class="toc-text">插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E6%9C%80%E5%B0%8F%E4%B8%8D%E5%B9%B3%E8%A1%A1%E5%AD%90%E6%A0%91"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">调整最小不平衡子树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-1"><span class="toc-number">1.6.2.</span> <span class="toc-text">删除操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88RBT"><span class="toc-number">1.7.</span> <span class="toc-text">红黑树（RBT)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A5%E6%BA%90%E4%B8%8E%E7%89%B9%E6%80%A7"><span class="toc-number">1.7.1.</span> <span class="toc-text">来源与特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE-1"><span class="toc-number">1.7.3.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">1.7.4.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">1.7.5.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">1.7.6.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91"><span class="toc-number">1.8.</span> <span class="toc-text">B树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%9F%A5%E6%89%BE%E6%95%88%E7%8E%87"><span class="toc-number">1.8.1.</span> <span class="toc-text">保证查找效率</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_10--%E6%8E%92%E5%BA%8F%E6%8A%80%E6%9C%AF/" title="数据结构_10--排序技术">数据结构_10--排序技术</a><time datetime="2024-12-18T08:33:56.000Z" title="Created 2024-12-18 16:33:56">2024-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_2--%E7%BA%BF%E6%80%A7%E8%A1%A8--%E9%A1%BA%E5%BA%8F%E8%A1%A8/" title="数据结构_2--线性表--顺序表">数据结构_2--线性表--顺序表</a><time datetime="2024-12-18T08:33:56.000Z" title="Created 2024-12-18 16:33:56">2024-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_3--%E7%BA%BF%E6%80%A7%E8%A1%A8--%E9%93%BE%E8%A1%A8/" title="数据结构_3--线性表--链表">数据结构_3--线性表--链表</a><time datetime="2024-12-18T08:33:56.000Z" title="Created 2024-12-18 16:33:56">2024-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_5--%E9%98%9F%E5%88%97/" title="数据结构_5--队列">数据结构_5--队列</a><time datetime="2024-12-18T08:33:56.000Z" title="Created 2024-12-18 16:33:56">2024-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_4--%E6%A0%88/" title="数据结构_4--栈">数据结构_4--栈</a><time datetime="2024-12-18T08:33:56.000Z" title="Created 2024-12-18 16:33:56">2024-12-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By tzw</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>