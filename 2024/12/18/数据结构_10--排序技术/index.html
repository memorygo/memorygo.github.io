<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>memorygo's blog | memorygo's blog</title><meta name="author" content="tzw"><meta name="copyright" content="tzw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="排序算法概念1sort,将关键字排成有序     算法的稳定性  12稳定：关键字相同的元素经过排序后相对顺序不会改变不稳定：相对位置改变  稳定 不一定 比不稳定好，要看具体情况  分类  12345内部排序：数据都在内存中(时间空间复杂度)外部排序：数据太多，无法全部放入内存(时间空间复杂度，读写磁盘的次数)  内存读写速度是硬盘的几百倍，所以不需要考虑内存的读写 插入排序 算法思想  1每次">
<meta property="og:type" content="article">
<meta property="og:title" content="memorygo&#39;s blog">
<meta property="og:url" content="http://example.com/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_10--%E6%8E%92%E5%BA%8F%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="memorygo&#39;s blog">
<meta property="og:description" content="排序算法概念1sort,将关键字排成有序     算法的稳定性  12稳定：关键字相同的元素经过排序后相对顺序不会改变不稳定：相对位置改变  稳定 不一定 比不稳定好，要看具体情况  分类  12345内部排序：数据都在内存中(时间空间复杂度)外部排序：数据太多，无法全部放入内存(时间空间复杂度，读写磁盘的次数)  内存读写速度是硬盘的几百倍，所以不需要考虑内存的读写 插入排序 算法思想  1每次">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png">
<meta property="article:published_time" content="2024-12-18T08:00:49.401Z">
<meta property="article:modified_time" content="2024-12-12T05:28:32.213Z">
<meta property="article:author" content="tzw">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_10--%E6%8E%92%E5%BA%8F%E6%8A%80%E6%9C%AF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'memorygo\'s blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-12-12 13:28:32'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="memorygo's blog"><span class="site-name">memorygo's blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Untitled</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-12-18T08:00:49.401Z" title="Created 2024-12-18 16:00:49">2024-12-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-12-12T05:28:32.213Z" title="Updated 2024-12-12 13:28:32">2024-12-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort,将关键字排成有序</span><br></pre></td></tr></table></figure>



<ul>
<li>算法的稳定性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">稳定：关键字相同的元素经过排序后相对顺序不会改变</span><br><span class="line">不稳定：相对位置改变</span><br></pre></td></tr></table></figure>

<p><u>稳定 不一定 比不稳定好，要看具体情况</u></p>
<ul>
<li>分类</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内部排序：数据都在内存中</span><br><span class="line">(时间空间复杂度)</span><br><span class="line"></span><br><span class="line">外部排序：数据太多，无法全部放入内存</span><br><span class="line">(时间空间复杂度，读写磁盘的次数)</span><br></pre></td></tr></table></figure>

<p><u>内存读写速度是硬盘的几百倍，所以不需要考虑内存的读写</u></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><ul>
<li>算法思想</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。</span><br></pre></td></tr></table></figure>



<ul>
<li>代码实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将比当前元素大的元素后移一位，当前元素插入到比它大的元素的前面</span><br><span class="line">(稳定)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//直接插入排序</span><br><span class="line">void InsertSort(int A[],int n)&#123;</span><br><span class="line">	int i,j,temp;</span><br><span class="line">	for(i=1;i&lt;n;i++)	//从头到尾逐个进行插入排序</span><br><span class="line">		if(A[i]&lt;A[i-1])&#123;</span><br><span class="line">			temp = A[i];</span><br><span class="line">			for(int j=i-1;j&gt;=0 &amp;&amp; A[i]&gt;temp;--j)</span><br><span class="line">				A[j+1]=A[j];			//后移一位</span><br><span class="line">			A[j+1]=temp;	//插入</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//直接插入排序(带哨兵)  -A[0] 代替temp</span><br><span class="line">void InsertSort(int A[],int n)&#123;</span><br><span class="line">	int i,j;</span><br><span class="line">	for(i=2;i&lt;=n;i++)</span><br><span class="line">		if(A[i]&lt;A[i-1])	&#123;</span><br><span class="line">			A[0]=A[i];</span><br><span class="line">			for(j=i-1;A[0]&lt;A[j];--j)&#123;</span><br><span class="line">				A[j+1] = A[j];</span><br><span class="line">			A[j+1] = A[0];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>效率分析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">空间复杂度: O(1)</span><br><span class="line">//辅助空间只用了temp</span><br><span class="line"></span><br><span class="line">时间复杂度: O(n的平方)</span><br><span class="line">//主要时间开销是 对比关键字，移动关键字</span><br><span class="line">若有n个关键字，需要处理n-1趟</span><br></pre></td></tr></table></figure>



<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对插入排序找插入位置的优化</span><br></pre></td></tr></table></figure>



<ul>
<li>代码分析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//二分插入排序</span><br><span class="line">void InsertSort(int A[],int n)&#123;</span><br><span class="line">	int i,j,low,high,mid;</span><br><span class="line">	for(i = 2;i&lt;=n;i++)&#123;</span><br><span class="line">		A[0]=A[i];</span><br><span class="line">		low=1;high=i-1;</span><br><span class="line">		while(low&lt;=high)&#123;</span><br><span class="line">			mid = (low+high)/2;</span><br><span class="line">			if(A[mid]&gt;A[0]) </span><br><span class="line">				high = mid-1;	//查找左半子表</span><br><span class="line">			else</span><br><span class="line">				low = mid+1;	//查找右半子表</span><br><span class="line">		&#125;</span><br><span class="line">		for(j=i-1;j&gt;=high+1;--j)</span><br><span class="line">			A[j+1] = A[j];	//后移</span><br><span class="line">		A[high+1] = A[0];	//插入，此时 high+1=low</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将【low,i-1】内的元素全部后移</p>
<h3 id="对链表进行插入排序"><a href="#对链表进行插入排序" class="headerlink" title="对链表进行插入排序"></a>对链表进行插入排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移动次数会变小，但是整体时间复杂度依然是O(n的平方)</span><br></pre></td></tr></table></figure>



<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素 基本有序，时间复杂度接近 O(n)</span><br></pre></td></tr></table></figure>





<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><ul>
<li>算法思想</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">先追求 局部有序，再逐渐 逼近全局有序</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分割若干子表：总表中间隔为d的所有元素分为一个子表</span><br><span class="line"></span><br><span class="line">先将 待排序表 分割成 若干子表，将各个子表进行直接插入排序，减小d，重复插入排序，直到d=1，就是在基本有序下，将所有元素进行直接插入排序。</span><br></pre></td></tr></table></figure>



<ul>
<li>代码实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该代码增量序列为 n/2,n/2/2,n/2/2/2 ...</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void ShellSort(int A[],int n)&#123;</span><br><span class="line">	int d,i,j;</span><br><span class="line">	//此处的A[0]只是暂存单元，不是哨兵</span><br><span class="line">	for(d=n/2;d&gt;=1;d=d/2)	//步长变化</span><br><span class="line">		for(i=d+1;i&lt;=n;++i)&#123;		//依次比较各子表</span><br><span class="line">			if(A[i]&lt;A[i-d])&#123;	//将A[i]插入有序增量子表</span><br><span class="line">				A[0]=A[i];		//暂存该元素</span><br><span class="line">				for(j=i-d;j&gt;0&amp;&amp;A[0]&lt;A[j];j-=d)</span><br><span class="line">					A[j+d]=A[j];	//子表中前移查找插入的位置</span><br><span class="line">									//若是比暂存的大，子表中元素后移，继续前找插入位置</span><br><span class="line">				A[j+d]=A[0];		//插入</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>代码实现 二</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接对子表进行插入排序</span><br></pre></td></tr></table></figure>



<ul>
<li>效率分析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度：</span><br><span class="line"></span><br><span class="line">取决于增量序列di的选择:</span><br><span class="line">最坏为 O(n^2)</span><br><span class="line">当n在某个范围内时，可达O(n^1.3)</span><br></pre></td></tr></table></figure>





<h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">经过排序后，相同关键字元素相对位置可能变化</span><br><span class="line">(不稳定)</span><br><span class="line"></span><br><span class="line">仅适用于顺序表，不适用于链表。</span><br><span class="line">因为需要d来快速定位</span><br></pre></td></tr></table></figure>





<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><ul>
<li>属于交换排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序、快速排序。</span><br><span class="line">根据两个元素关键字的比较结果来对换这两个记录在序列中的位置</span><br></pre></td></tr></table></figure>



<ul>
<li>算法思想</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">顺序：自己定义升序还是降序</span><br><span class="line"></span><br><span class="line">第一趟：</span><br><span class="line">从后往前(或从前往后)两两比较相邻元素的值，若为逆序，则交换顺序，交换完整个序列后 此时最前(或最后)元素是符合顺序序列的位置。</span><br><span class="line"></span><br><span class="line">从后往前冒泡第一趟后 是最前面元素(第一个元素)符合顺序。此后第一个元素不用参与排序，继续从后往前冒泡一趟，此时最前面(第二个元素)也符合了顺序。</span><br><span class="line">以此类推，一直冒泡到所有元素符合顺序</span><br><span class="line"></span><br><span class="line">当某一趟，没有依次交换操作，则代表所有元素有序,可以提前结束</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两个元素相同时，不交换位置</span><br><span class="line">(稳定)</span><br></pre></td></tr></table></figure>



<ul>
<li>代码实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void swap(int &amp;a,int &amp;b)&#123;</span><br><span class="line">	int temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void BubbleSort(int A[],int n)&#123;</span><br><span class="line">	for(int i=0;i&lt;n-1;i++)&#123;		//i之前为有序</span><br><span class="line">		bool flag = false;</span><br><span class="line">		for(int j=n-1;j&gt;i;j--)	//从后往前冒泡</span><br><span class="line">			if(A[j-1]&gt;A[j])&#123;	//逆序条件，交换</span><br><span class="line">				swap(A[j-1],A[j]);</span><br><span class="line">				flag = true;</span><br><span class="line">			&#125;</span><br><span class="line">		if(flag = false)</span><br><span class="line">			return;		//说明有序，退出排序</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>效率分析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">空间复杂度O(1)</span><br><span class="line">时间复杂度O(n^2)</span><br></pre></td></tr></table></figure>



<h3 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">顺序表、链表</span><br></pre></td></tr></table></figure>





<h2 id="快速排序-代码必会"><a href="#快速排序-代码必会" class="headerlink" title="快速排序[代码必会]"></a>快速排序[代码必会]</h2><ul>
<li>算法思想</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在带排序表中取一个基准元素(通常取首元素),通过排序将待排序表划分为两个子表，左子表都是小于基准的元素，右子表都是大于等于基准的元素。</span><br><span class="line"></span><br><span class="line">然后分别递归对左右两个子表进行 取基准，再次划分。</span><br><span class="line"></span><br><span class="line">直到划分的子表只有一个元素或为空，结束。</span><br><span class="line">此时该子表的low=high(! low&lt;high)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">划分具体实现：</span><br><span class="line">	首元素作为基准时，定义两个指针：low，high。low指向基准元素，high指向表尾元素。</span><br><span class="line">	</span><br><span class="line">	1.将low指向的基准元素取出</span><br><span class="line">	</span><br><span class="line">	2.high指向的元素大小判断是否大于等于基准，若是则high指针前移一位，继续进行2操作;若不是，则将该元素移动到low指向的空位置(此前的基准元素已经被取出)，然后进行3操作。</span><br><span class="line">	</span><br><span class="line">	3.low指针后移一位。此时判断low指向的元素大小是否小于基准，若是，继续进行操作3;若不是，则将该元素移动到high执行的空位置(此前的high元素已经被移动到了low的左边)。</span><br><span class="line">	</span><br><span class="line">	4.high指针前移一位。此时判断high指向的元素大小是否大于等于基准，若是，继续进行操作4;若不是，则将该元素移动到low执行的空位置(此前的low元素已经被移动到了high的右边)</span><br><span class="line">	</span><br><span class="line">	5.循环3，4操作，直到 high = low，此时他们指向的一定是空位置，我们将基准元素放入该位置。</span><br><span class="line">	</span><br><span class="line">	6.我们成功将待排序表划分为了左右子表，此后我们分别递归地对左右子表进行再次划分，直到划分子表只有一个元素或为空时，代表快速排序结束</span><br></pre></td></tr></table></figure>



<ul>
<li>代码实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//用首元素作为基准划分表</span><br><span class="line">int Partition(int A[],int low,int high)&#123;</span><br><span class="line">	int pivot=A[low];		//基准元素取出</span><br><span class="line">	while(low&lt;high)&#123;</span><br><span class="line">		while(low&lt;high&amp;&amp;A[high]&gt;=pivot)	</span><br><span class="line">			--high;</span><br><span class="line">		A[low] = A[high];		//high指向元素移动到low位置</span><br><span class="line">		while(low&lt;high&amp;&amp;A[low]&lt;pivot)</span><br><span class="line">			++low;</span><br><span class="line">		A[high] = A[low];		//low指向元素移动到high位置</span><br><span class="line">	&#125;</span><br><span class="line">	A[low] = pivot ;		//最后填入基准元素</span><br><span class="line">	return low;		//返回基准的位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//快速排序</span><br><span class="line">void QuickSort(int A[],int low,int high)&#123;</span><br><span class="line">	if(low&lt;high)&#123;</span><br><span class="line">		int pivotpos = Partition(A,low,high); //划分</span><br><span class="line">		QuickSort(A,low,Pivotpos-1);	//递归划分左子表</span><br><span class="line">		QucikSort(A,Pivotpos+1,high);	//递归划分右子表</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pivot 基准，pivotpos 基准点</p>
<ul>
<li>算法效率分析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">每一次的QuickSort只需要处理剩余的待排序元素</span><br><span class="line">	时间复杂度 = O(n*递归深度)</span><br><span class="line">			  = O(nlog_2 n)最好 /O(n^2) 最坏</span><br><span class="line">			  </span><br><span class="line">	快排一般是接近最好效率，所以平均时间复杂度 = O(nlog_2 n)</span><br><span class="line">	</span><br><span class="line">	空间复杂度 = O(递归深度)</span><br><span class="line">			= O(log_2 n)最好 /O(n) 最坏</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每一层的QuickSort可以组成一棵二叉树，二叉树的层数就是递归调用的深度。</span><br><span class="line">n个结点的二叉树最小高度:[log_2 n]+1</span><br><span class="line">最大高度:n</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/6752e3d2d0e0a243d4def5ee.png"><img src="https://pic.imgdb.cn/item/6752e3d2d0e0a243d4def5ee.png" alt="item.filename"></a> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最好情况：</span><br><span class="line">	每次选中的基准将待排序序列划分为均匀的两个部分，则二叉树高度最小，递归深度最小，算法效率最高</span><br><span class="line">	</span><br><span class="line">最坏情况：</span><br><span class="line">	待排序表为 有序或逆序 序列时，只有不断划分的右(左)子表，每一层只有一个表，即二叉树每一层只有右(左)子树。</span><br></pre></td></tr></table></figure>



<ul>
<li>稳定性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不稳定</span><br></pre></td></tr></table></figure>



<ul>
<li>注意</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一趟排序 ！= 一次划分</span><br></pre></td></tr></table></figure>





<h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在表中的头中后三个位置的元素进行对比，选取中间值作为基准元素。</span><br><span class="line">2.随机选取元素作为基准元素</span><br></pre></td></tr></table></figure>



<ul>
<li>代码实现【直接交换？？】</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int partition(int arr[], int low, int high) &#123;</span><br><span class="line">    int pivot = medianOfThree(arr, low, high);</span><br><span class="line">    int i = low - 1;</span><br><span class="line">    for (int j = low; j &lt;= high - 1; j++) &#123;</span><br><span class="line">        if (arr[j] &lt; arr[pivot]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[i + 1], &amp;arr[pivot]);</span><br><span class="line">    return i + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分为：</span><br><span class="line">简单选择排序</span><br><span class="line">堆排序</span><br></pre></td></tr></table></figure>



<ul>
<li>算法思想</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每一趟在待排序元素中选取关键字最小(或最大)的元素加入有序子序列</span><br></pre></td></tr></table></figure>



<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每一趟在待排序元素中选取关键字最小(或最大)的元素加入有序子序列</span><br></pre></td></tr></table></figure>



<ul>
<li>代码实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//简单选择排序</span><br><span class="line">void SelectSort(ing A[],int n)&#123;</span><br><span class="line">	for(int i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">		int min = i;</span><br><span class="line">		for(int j=i+1;j&lt;n;j++)</span><br><span class="line">			if(A[j]&lt;A[min]) min = j;</span><br><span class="line">		if(min != i) swap(A[i],A[min])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void swap(int &amp;a,int &amp;b)&#123;</span><br><span class="line">	int temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>效率分析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度 O(n^2)</span><br><span class="line">空间复杂度 O(1)</span><br></pre></td></tr></table></figure>



<ul>
<li>适用性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不稳定</span><br><span class="line">顺序表，链表都可用</span><br></pre></td></tr></table></figure>





<h3 id="堆排序-代码必会"><a href="#堆排序-代码必会" class="headerlink" title="堆排序 [代码必会]"></a>堆排序 [代码必会]</h3><h4 id="大小根堆"><a href="#大小根堆" class="headerlink" title="大小根堆"></a>大小根堆</h4><p>​	对于二叉树的顺序存储</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i的左孩子	2i</span><br><span class="line">i的右孩子	2i+1</span><br><span class="line">i的父节点	[i/2]</span><br><span class="line">i所在的层数	[log_2 (n+1)] 或 [log_2 n] + 1</span><br></pre></td></tr></table></figure>

<p>​	完全二叉树有n个结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">判断i是否有左孩子	</span><br><span class="line">2i &lt;= n </span><br><span class="line">判断i是否有右孩子	</span><br><span class="line">2i+1 &lt;= n</span><br><span class="line">判断i是否是叶子/分支结点	</span><br><span class="line">i&gt;[n/2]</span><br></pre></td></tr></table></figure>



<p>什么是堆？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">顺序存储的完全二叉树</span><br></pre></td></tr></table></figure>



<p><strong>大根堆</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">满足：A[i] &gt;= A[2i] and A[i] &gt;= A[2i+1]	1&lt;=i&lt;=n/2</span><br><span class="line"></span><br><span class="line">即，完全二叉树中，所有根结点值大于左、右结点值</span><br><span class="line"></span><br><span class="line">根 &gt;= 左、右 </span><br></pre></td></tr></table></figure>



<p><strong>小根堆</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">满足：A[i] &lt;= A[2i] and A[i] &lt;= A[2i+1]	1&lt;=i&lt;=n/2</span><br><span class="line"></span><br><span class="line">即，完全二叉树中，所有根结点值小于左、右结点值</span><br><span class="line"></span><br><span class="line">根 &lt;= 左、右 </span><br></pre></td></tr></table></figure>



<h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><ul>
<li>核心思想</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每一趟在待排序元素中选取关键字最小(或最大)的元素加入有序子序列</span><br></pre></td></tr></table></figure>

<ul>
<li>具体思路</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将待排序序列，转化为大、小根堆，然后进行堆排序</span><br></pre></td></tr></table></figure>



<p>转化为大小根堆</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">根堆数组要求从下标1开始存元素</span><br><span class="line"></span><br><span class="line">待排序序列的长度 n </span><br><span class="line">1. n/2 得到 最后面的根结点位置i	[非终端结点(分支)的末节点]</span><br><span class="line">2. 检查根的左右孩子是否满足与根结点的关系</span><br><span class="line">3. 若不满足，则进行调整（例如，转化大根堆，若孩子大于根，则将较大的孩子与根互换位置）</span><br><span class="line">4. 调整后 i--，继续处理根结点</span><br><span class="line">5. 处理完 i = 1的最前根结点，转化完成</span><br><span class="line"></span><br><span class="line">过程3的调整中，若破坏了下一级的堆，则采用相同方式继续往下调整(处理下坠)</span><br></pre></td></tr></table></figure>



<p>堆排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">每一趟将堆顶元素加入有序子序列</span><br><span class="line">1. 将 大根堆数组的 堆顶元素 与 最后一个元素交换</span><br><span class="line">2. 堆数组长度 len --</span><br><span class="line">3. 此时 堆顶 再次下坠调整为大根堆</span><br><span class="line">4. 返回 1 操作</span><br><span class="line">最后将大根堆数组变成了升序数组</span><br><span class="line"></span><br><span class="line">(基于大根堆排序)</span><br></pre></td></tr></table></figure>





<ul>
<li>代码实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//建立大根堆</span><br><span class="line">void BuildMaxHeap(int A[],int len)&#123;</span><br><span class="line">	for(int i=len/2;i&gt;0;i--)	//从后往前调整所有非终端结点</span><br><span class="line">		HeadAdjust(A,i,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将以k为根的子树 调整为大根堆</span><br><span class="line">void HeapAdjust(int A[],int k,int len)&#123;</span><br><span class="line">	A[0] = A[k];		//A[0] 暂存 子树的根节点</span><br><span class="line">	for(int i=2*k;i&lt;=len;i=i*2)&#123;    //延key较大子结点下坠</span><br><span class="line">		if(i&lt;len &amp;&amp; A[i]&lt;A[i+1])</span><br><span class="line">			i++;				//左右结点，选取较大的子结点</span><br><span class="line">		if(A[0] &gt;= A[i]) break;		//说明不用调整，退出</span><br><span class="line">		else&#123;					//调整</span><br><span class="line">			A[k] = A[i];</span><br><span class="line">			k = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	A[k] = A[0];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//堆排序(大根堆)</span><br><span class="line">void HeapSort(int A[],int len)&#123;</span><br><span class="line">	BuildMaxHeap(A,len)</span><br><span class="line">	for(int i=len;i&gt;1;i--)&#123;</span><br><span class="line">		swap(A[i],A[1]);		//堆顶元素和堆底元素交换</span><br><span class="line">		HeadAdjust(A,1,i-1);	//破坏后的堆向下调整</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>i&lt;len</code> 让只有一个子树的分支结点只用对比一次</p>
<ul>
<li>结论</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个结点，每下坠一层，最多只需要对比关键字两次</span><br><span class="line"></span><br><span class="line">若树高为h，某结点在i层，则将这个结点向下调整最多只需要下坠h-1层，关键字对比不超过(h-1)*2</span><br></pre></td></tr></table></figure>



<ul>
<li>效率分析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n个结点的完全二叉树树高 h = [log_2 n] + 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">建堆的过程，关键字对比次数不超过 4n，建堆时间复杂度=O(n)</span><br><span class="line">每一趟排序不超过O(log_2 n)</span><br><span class="line"></span><br><span class="line">总的时间复杂度=O(nlog_2 n)</span><br><span class="line">空间复杂度 = O(1)	//固定数量的几个常量</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不稳定</span><br></pre></td></tr></table></figure>





<h4 id="小根堆练习"><a href="#小根堆练习" class="headerlink" title="小根堆练习"></a>小根堆练习</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">// 转化小根堆，进行堆排序</span><br><span class="line"></span><br><span class="line">// 以k为根的子树，调整为大根堆</span><br><span class="line">void HeapAdjust(int A[], int k, int len)</span><br><span class="line">&#123;</span><br><span class="line">    A[0] = A[k]; // 暂存 子树的根结点 k 的值</span><br><span class="line">    for (int i = 2 * k; i &lt;= len; i *= 2)</span><br><span class="line">    &#123; // 循环 处理下坠</span><br><span class="line">        if (i &lt; len &amp;&amp; A[i] &gt; A[i + 1])</span><br><span class="line">            i++; // 选取较小结点</span><br><span class="line">        if (A[0] &lt;= A[i])</span><br><span class="line">            break; // 满足小根堆条件</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            A[k] = A[i]; // 将根与较小子结点交换位置                        下坠必然还是比较A[0]</span><br><span class="line">            k = i;       // 让交换完后的节点位置，继续向下调整小根堆</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[0]; // 下坠完成后，最顶部根值 替换 到结束位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 建立小根堆</span><br><span class="line">void BuildMinHeap(int A[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = len / 2; i &gt; 0; i--)</span><br><span class="line">    &#123; // 从后往前调整所有非终端结点</span><br><span class="line">        HeapAdjust(A, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 交换</span><br><span class="line">void swap(int &amp;a, int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    int tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 进行堆排序,堆顶为最小值，交换到最后，形成降序排列</span><br><span class="line">void HeapSort(int A[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    BuildMinHeap(A, len);</span><br><span class="line">    for (int i = len; i &gt; 1; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(A[i], A[1]);        // 堆顶和堆底元素交换</span><br><span class="line">        HeapAdjust(A, 1, i - 1); // 只替换了堆顶元素，只需直接调整一次，就能更新大根堆。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int num[10];</span><br><span class="line">    int n, x;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    x = n;</span><br><span class="line">    while (x)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; num[x--];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    HeapSort(num, n);</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="堆的插入删除"><a href="#堆的插入删除" class="headerlink" title="堆的插入删除"></a>堆的插入删除</h4><p>插入新元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一路上升,直到无法上升</span><br></pre></td></tr></table></figure>



<p>删除元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">删除后，用堆底元素替换到删除的位置，然后调整当前子树，进行下坠</span><br></pre></td></tr></table></figure>





<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>:把两个或多个已经有序的序列合并成一个有序序列</p>
<ul>
<li>2路归并</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用i，j指针分别指向两个升序序列的头元素</span><br><span class="line">k指针指向合并数组的头位置</span><br><span class="line"></span><br><span class="line">1. 比较 i，j，将较小元素填入k中</span><br><span class="line">2. k和填入元素指针 后移</span><br><span class="line">3. 当i指针序列越界后，j指向的序列剩余部分全部填入合并数组</span><br><span class="line">（反之亦然）</span><br></pre></td></tr></table></figure>



<ul>
<li>4路归并</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类似2路</span><br></pre></td></tr></table></figure>





<ul>
<li>归并排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不断 2路归并 实现排序</span><br><span class="line"></span><br><span class="line">1. 将每个元素看成 只有一个元素的有序序列</span><br><span class="line">2. 将 每两个有序序列 进行归并</span><br><span class="line">3. 再次 将每两个有序序列进行 归并 直到排序完毕</span><br></pre></td></tr></table></figure>



<ul>
<li>代码实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int *B = (int *)malloc(sizeof(int));</span><br><span class="line">//辅助数组</span><br><span class="line"></span><br><span class="line">//合并 A[low,mid] 和 A[mid+1,high] 两个有序序列</span><br><span class="line">void Merge(int A[],int low,int mid,int high)&#123;</span><br><span class="line">	int i,j,k;</span><br><span class="line">	for(k=low;k&lt;=high;k++)</span><br><span class="line">		B[k] = A[k];		//保存原序列</span><br><span class="line">	for(i=low,j=mid+1,k=i;i&lt;=mid&amp;&amp;j&lt;=high;k++)&#123;</span><br><span class="line">		if(B[i]&lt;=B[j])</span><br><span class="line">			A[k] = B[i++];</span><br><span class="line">		else</span><br><span class="line">			A[k] = B[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	//将剩余的元素直接填入</span><br><span class="line">	while(i&lt;=mid)	A[k++] = B[i++];</span><br><span class="line">	while(j&lt;=high)	A[k++] = B[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//归并排序，给出排序范围</span><br><span class="line">void MergeSort(int A[],int low,int high)&#123;</span><br><span class="line">	if(low&lt;high)&#123;</span><br><span class="line">		int mid = (low+high)/2;</span><br><span class="line">		MergeSort(A,low,mid);	//左半进行归并</span><br><span class="line">		MergeSort(A,mid+1,high);	//右半进行归并</span><br><span class="line">		Merge(A,low,mid,high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">归并排序 本质上是倒立的二叉树</span><br></pre></td></tr></table></figure>



<ul>
<li>效率分析</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n个元素进行2路归并排序，归并趟数log_2 n</span><br><span class="line">时间复杂度O(nlog_2 n)</span><br><span class="line">空间复杂度O(n)	辅助数组</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">稳定</span><br></pre></td></tr></table></figure>



<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Radix Sort</span><br></pre></td></tr></table></figure>



<ul>
<li>特点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不基于比较的排序</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通常用于	链式存储	排序</span><br></pre></td></tr></table></figure>





<ul>
<li>算法思想</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基数为10 的基数排序：（降序序列）</span><br><span class="line">1. 初始化 设置9个空队列，编号1~9</span><br><span class="line">2. 按照关键字位，从低到高位的次序的所有元素进行 分配，收集</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分配：顺序扫描各个元素，按元素的关键字位将其插入对于的队列尾部</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">收集：把各个队列中的结点依次出队并链接</span><br></pre></td></tr></table></figure>





<ul>
<li>代码实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LinkNode&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct LinkNode *next;</span><br><span class="line">&#125;LinkNode,*LinkList;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">	LinkNode *front,*rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<ul>
<li>效率</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">空间复杂度 O(r)	需要r个辅助队列</span><br><span class="line"></span><br><span class="line">分配收集 d 趟</span><br><span class="line">一趟分配O(n),收集O(r)</span><br><span class="line">时间复杂度 O(d(n+r))</span><br></pre></td></tr></table></figure>



<ul>
<li>适用范围</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">d 较小（关键字位次）</span><br><span class="line">r 较小 （基数，关键字取值范围）</span><br><span class="line">n 较大 （元素个数）</span><br></pre></td></tr></table></figure>





<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当数据元素过多，无法一次全部读入内存进行排序</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">采用外部磁盘到内存之间的归并排序</span><br></pre></td></tr></table></figure>





<ul>
<li>算法思想</li>
</ul>
<p>&#96;</p>
<ul>
<li>效率分析</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">tzw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_10--%E6%8E%92%E5%BA%8F%E6%8A%80%E6%9C%AF/">http://example.com/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_10--%E6%8E%92%E5%BA%8F%E6%8A%80%E6%9C%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_T1--%E5%BC%95%E5%AD%90/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9--%E6%9F%A5%E6%89%BE/" title=""><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">tzw</div><div class="author-info__description">this is memorygo's house</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/memorygo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.1.</span> <span class="toc-text">折半插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">对链表进行插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.3.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">1.4.1.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E4%BB%A3%E7%A0%81%E5%BF%85%E4%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">快速排序[代码必会]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF"><span class="toc-number">1.5.1.</span> <span class="toc-text">优化思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">简单选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F-%E4%BB%A3%E7%A0%81%E5%BF%85%E4%BC%9A"><span class="toc-number">1.6.2.</span> <span class="toc-text">堆排序 [代码必会]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E6%A0%B9%E5%A0%86"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">大小根堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E6%A0%B9%E5%A0%86%E7%BB%83%E4%B9%A0"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">小根堆练习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">堆的插入删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.</span> <span class="toc-text">外部排序</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_T2--%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/" title="Untitled">Untitled</a><time datetime="2024-12-18T08:00:49.412Z" title="Created 2024-12-18 16:00:49">2024-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_T1--%E5%BC%95%E5%AD%90/" title="Untitled">Untitled</a><time datetime="2024-12-18T08:00:49.407Z" title="Created 2024-12-18 16:00:49">2024-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_10--%E6%8E%92%E5%BA%8F%E6%8A%80%E6%9C%AF/" title="Untitled">Untitled</a><time datetime="2024-12-18T08:00:49.401Z" title="Created 2024-12-18 16:00:49">2024-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9--%E6%9F%A5%E6%89%BE/" title="Untitled">Untitled</a><time datetime="2024-12-18T08:00:49.392Z" title="Created 2024-12-18 16:00:49">2024-12-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7--%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/" title="Untitled">Untitled</a><time datetime="2024-12-18T08:00:49.384Z" title="Created 2024-12-18 16:00:49">2024-12-18</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By tzw</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>