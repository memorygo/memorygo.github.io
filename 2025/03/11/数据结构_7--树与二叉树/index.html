<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构_7--树与二叉树 | memorygo's blog</title><meta name="author" content="tzw"><meta name="copyright" content="tzw"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="title: 数据结构_7–树与二叉树date: 2024&#x2F;12&#x2F;18 16:33:56树与二叉树树的逻辑结构逻辑结构：该数据结构，理论逻辑上由什么组成。 树的基本概念树是无序的   空树——结点数为0的树 非空树的特性：  有且仅有一个根结点 没有后继的结点——叶子结点 有后继的结点——分支结点 处了根结点外，任何结点都有且仅有一个前驱 每个结点可以有0个或多个后继   任">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构_7--树与二叉树">
<meta property="og:url" content="http://example.com/2025/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7--%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="memorygo&#39;s blog">
<meta property="og:description" content="title: 数据结构_7–树与二叉树date: 2024&#x2F;12&#x2F;18 16:33:56树与二叉树树的逻辑结构逻辑结构：该数据结构，理论逻辑上由什么组成。 树的基本概念树是无序的   空树——结点数为0的树 非空树的特性：  有且仅有一个根结点 没有后继的结点——叶子结点 有后继的结点——分支结点 处了根结点外，任何结点都有且仅有一个前驱 每个结点可以有0个或多个后继   任">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png">
<meta property="article:published_time" content="2025-03-11T07:36:44.000Z">
<meta property="article:modified_time" content="2025-03-11T07:36:44.829Z">
<meta property="article:author" content="tzw">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7--%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构_7--树与二叉树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-11 15:36:44'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="memorygo's blog"><img class="site-icon" src="https://pic1.imgdb.cn/item/67cadec9066befcec6e06266.png"/><span class="site-name">memorygo's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构_7--树与二叉树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-11T07:36:44.000Z" title="Created 2025-03-11 15:36:44">2025-03-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-11T07:36:44.829Z" title="Updated 2025-03-11 15:36:44">2025-03-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构_7--树与二叉树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><hr>
<h2 id="title-数据结构-7–树与二叉树date-2024-12-18-16-33-56"><a href="#title-数据结构-7–树与二叉树date-2024-12-18-16-33-56" class="headerlink" title="title: 数据结构_7–树与二叉树date: 2024&#x2F;12&#x2F;18 16:33:56"></a>title: 数据结构_7–树与二叉树<br>date: 2024&#x2F;12&#x2F;18 16:33:56</h2><h1 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h1><h2 id="树的逻辑结构"><a href="#树的逻辑结构" class="headerlink" title="树的逻辑结构"></a>树的逻辑结构</h2><p>逻辑结构：该数据结构，理论逻辑上由什么组成。</p>
<h3 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h3><p>树是<strong>无序的</strong> </p>
<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/6718a932d29ded1a8ca0c9e3.png"><img src="https://pic.imgdb.cn/item/6718a932d29ded1a8ca0c9e3.png"></a></p>
<p>空树——结点数为0的树</p>
<p>非空树的特性：</p>
<ul>
<li>有且仅有一个根结点</li>
<li>没有后继的结点——叶子结点</li>
<li>有后继的结点——分支结点</li>
<li>处了根结点外，任何结点都<strong>有且仅有一个前驱</strong></li>
<li>每个结点可以有0个或多个后继</li>
</ul>
<p> 任何一个树，都可以看作一个根结点和若干个不相干的子树( 空树也是树 )构成。</p>
<p>操作系统的文件目录——树的应用</p>
<p><strong>路径</strong> </p>
<p>结点之间的路径——只能<strong>从上往下</strong> </p>
<p>属性：</p>
<p>结点的<strong>层次</strong>（深度）——从上往下数</p>
<p>结点的<strong>高度</strong>——从下往上数</p>
<p>树的高度（深度）—— 总共多少层</p>
<p><strong>结点的度</strong> —— 有几个分支 ,拥有子树的个数</p>
<p><strong>树的度</strong> —— 树中各结点的度的最大值</p>
<p><strong>叶子结点</strong> 度为0</p>
<p><strong>分支结点</strong> 度不为0</p>
<p>层序编号：将树中结点按照从上至下，从左至右编号</p>
<h3 id="有序树、无序树、森林"><a href="#有序树、无序树、森林" class="headerlink" title="有序树、无序树、森林"></a>有序树、无序树、森林</h3><p>有序树——逻辑上看，树中结点的各子树从左至右是<strong>有次序</strong>的，不能互换</p>
<p>有序树——逻辑上看，树中结点的各子树从左至右是<strong>无次序</strong>的，不能互换</p>
<p>森林——是m棵互不相交的树都集合</p>
<p>森林可以和树相互转化</p>
<h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><h4 id="常见性质1："><a href="#常见性质1：" class="headerlink" title="常见性质1："></a>常见性质1：</h4><p><strong>结点数&#x3D;总度数(各结点的度数之和)+1</strong></p>
<h4 id="常见性质2："><a href="#常见性质2：" class="headerlink" title="常见性质2："></a>常见性质2：</h4><p><strong>度为m的树，m叉树的区别</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">树的度，各结点的度的最大值</span><br><span class="line"></span><br><span class="line">m叉树——每个结点最多只能有m个分支</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="常见性质-3："><a href="#常见性质-3：" class="headerlink" title="常见性质 3："></a>常见性质 3：</h4><p><strong>度为m的树第i层至多有m的i-1次方个结点</strong></p>
<table>
<thead>
<tr>
<th>层数</th>
<th>最多结点数</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>m</td>
</tr>
<tr>
<td>3</td>
<td>m*m</td>
</tr>
</tbody></table>
<h4 id="常见性质-4："><a href="#常见性质-4：" class="headerlink" title="常见性质 4："></a>常见性质 4：</h4><p><strong>高度为h的m叉树 至多 有( m的h次方-1 )除以 (m-1 )个结点</strong> </p>
<p>1 + m + m*m + … + m的h-1次方</p>
<p>等比数列求和</p>
<h4 id="常见性质-5："><a href="#常见性质-5：" class="headerlink" title="常见性质 5："></a>常见性质 5：</h4><p><strong>高度为h的m叉树至少有h个结点</strong> </p>
<p><strong>高度为h，度为m的树至少有 h+m-1个结点</strong>  </p>
<p>每层一个结点</p>
<h4 id="常见性质-6："><a href="#常见性质-6：" class="headerlink" title="常见性质 6："></a>常见性质 6：</h4><p>具有n个结点的m叉树都最小高度为 [logm (n(m-1)+1)]</p>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>从根结点出发，按照某种次序访问树中所有结点，使得每个结点被访问一次，</p>
<p>且仅被访问一次</p>
<p><strong>后序遍历</strong> </p>
<p>从左往右，从下往上遍历</p>
<p><strong>(前)先序遍历</strong> </p>
<p>从左往右，从上往下遍历</p>
<p><strong>层序遍历</strong></p>
<p>将树中结点按照从上至下，从左至右编号</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是 n 个结点 的有限集合：</p>
<ul>
<li>n&#x3D; 0,空二叉树</li>
<li>由一个根结点和两个互不相交的左子树和右子树。左右子树也是二叉树。</li>
</ul>
<p>特点：</p>
<ul>
<li>每个结点至多只有两棵子树</li>
<li>二叉树 是 <strong>有序的</strong>，次序不能颠倒，左右子树不能颠倒</li>
</ul>
<p>二叉树的五种状态</p>
<ul>
<li>空二叉树</li>
<li>只有根结点</li>
<li>只有左子树</li>
<li>只有右子树</li>
<li>左右子树都有</li>
</ul>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>一棵高度为h，且包含 2的h次方 -1 个结点 的二叉树</p>
<p>最后一层 叶子是满的</p>
<p>特点：</p>
<ul>
<li>叶子结点只能出现在最下一层</li>
<li>只有度为0和度为2的结点</li>
<li>层序编号，从1开始编号，结点i的左孩子为2i，右孩子为2i+1;结点i的父结点为[i&#x2F;2]（如果有的话）</li>
</ul>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>当二叉树中每个结点都与高度相同的满二叉树中，层序编号1~n(结点数) 对应相同时，就称为完全二叉树。</p>
<p>满二叉树是一种特殊的完全二叉树</p>
<p>特点：</p>
<ul>
<li>只有最后两层可能有叶子结点</li>
<li>最多只有一个结点????</li>
<li>i&gt;[n&#x2F;2]为叶子结点，i&lt;&#x3D;[n&#x2F;2]为分支结点</li>
</ul>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p><code>左子树</code>上所有节点的关键字均小于根结点的关键字</p>
<p><code>右子树</code>上所有结点的关键字均大于根结点的关键字</p>
<p>左子树和右子树又各是一棵二叉排序树</p>
<p>可用于元素的排序、搜索</p> 



<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p>树上任一结点的左子树和右子树的深度之差不超过1。</p>
<p>平衡二叉树能有更高的搜索效率</p>
<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/6721e798d29ded1a8c1f450e.png"><img src="https://pic.imgdb.cn/item/6721e798d29ded1a8c1f450e.png"></a> </p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><h4 id="常用性质1："><a href="#常用性质1：" class="headerlink" title="常用性质1："></a>常用性质1：</h4><p>设非空二叉树中度为0，1和2的结点个数分别为n0,n1和n2,则 <strong>n0&#x3D;n2+1</strong> </p>
<p>(叶子结点比二分支结点多一个)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结点总数为n</span><br><span class="line">n = n0+n1+n2</span><br><span class="line">n = n1 + 2*n2 + 1</span><br><span class="line">//树的结点数 = 总度数 + 1</span><br></pre></td></tr></table></figure>



<h4 id="常用性质2："><a href="#常用性质2：" class="headerlink" title="常用性质2："></a>常用性质2：</h4><p>二叉树第i层至多有$2^{i-1}$个结点</p>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><p>树是一个非线性结构，但是我们在计算机中 用线性结构实现</p>
<h3 id="二叉树顺序存储"><a href="#二叉树顺序存储" class="headerlink" title="二叉树顺序存储"></a>二叉树顺序存储</h3><p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/6719de73d29ded1a8ca9f928.png"><img src="https://pic.imgdb.cn/item/6719de73d29ded1a8ca9f928.png"></a> </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    ElemType value;		<span class="comment">//结点中的数据元素</span></span><br><span class="line">    <span class="type">bool</span> isEmpty;	<span class="comment">//结点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> <span class="title">t</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，所有节点设为空</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; MaxSize; i++) &#123;</span><br><span class="line">	t[i].isEmpty=<span class="literal">true</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>需要体现结点之间的关系</p>
<p>完全二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i的父类	 i/2</span><br><span class="line">i的左孩子	2i</span><br><span class="line">i的右孩子 	2i + 1</span><br></pre></td></tr></table></figure>



<p>树的顺序存储</p>
<p>将树补全为完全二叉树，补来的结点设为空。</p>
<p>问题：</p>
<p>​	浪费空间，补来的节点需要作标志</p>
<h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><p>更常用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>	<span class="comment">//指向左孩子和右孩子的指针</span></span><br><span class="line">&#125;BiNode,*BiTree;</span><br></pre></td></tr></table></figure>



<p>n个结点 有 2n个指针，有n+1个指针是空的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//定义一棵空树</span><br><span class="line">BiTree root = NULL;</span><br><span class="line"></span><br><span class="line">//插入根结点</span><br><span class="line">root = (BiTree) malloc(sizeof(BiNode));</span><br><span class="line">root-&gt;data=&#123;1&#125;;</span><br><span class="line">root-&gt;lchild=NULL;</span><br><span class="line">root-&gt;rchild=NULL;</span><br><span class="line"></span><br><span class="line">//插入新结点</span><br><span class="line">BiTNode *p=(BiTNode *)malloc(sizeof(BiTNode));</span><br><span class="line">p-&gt;data=&#123;2&#125;;</span><br><span class="line">p-&gt;lchild=NULL;</span><br><span class="line">p-&gt;rchild=NULL;</span><br><span class="line">root-&gt;lchild=p;</span><br></pre></td></tr></table></figure>



<p>虽然找到孩子很简单，但是若要找父亲则是需要从根结点遍历，十分麻烦</p>
<p>这时我们就需要三叉链表</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BiTNode&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct BiTNode *lchild,*rchild;</span><br><span class="line">	struct BiTNode *parent;</span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>



<p>不经常找父类就直接用二叉链表</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>根据二叉树的 递归特性 制订的 <strong>遍历规则</strong> </p>
<p>递归特性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.要么是个空二叉树</span><br><span class="line">2.要么是由 “ 根节点 + 左子树 + 右子树 ” 组成的二叉树</span><br></pre></td></tr></table></figure>



<p>对于非空二叉树采用的遍历规则</p>
<ul>
<li>先序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根左右 NLR</span><br></pre></td></tr></table></figure>


<ul>
<li>中序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左根右 LNR</span><br></pre></td></tr></table></figure>

<ul>
<li>后序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">左右根 LRN</span><br></pre></td></tr></table></figure>



<p><strong>每遍历到一个树节点，都要执行对应的遍历规则</strong> </p>
<p>一个算数表达式的树构建，可以通过前中后遍历，输出前中后缀表达式</p>
<ul>
<li>层序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">初始化一个辅助队列</span><br><span class="line">根结点入队</span><br><span class="line">若队列非空，队头结点出队，访问该结点，将其左，右孩子插入队尾。</span><br><span class="line">（入队出队实际只用指针就行，无需使用实际节点）</span><br></pre></td></tr></table></figure>











<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PreOrder(BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">    if (T!=NULL)&#123;</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;lchild);	//递归遍历左子树</span><br><span class="line">        PreOrder(T-&gt;rchild);	//递归遍历右子树</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PostOrder(BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">    if (T!=NULL)&#123;</span><br><span class="line">        PreOrder(T-&gt;lchild);	//递归遍历左子树</span><br><span class="line">        PreOrder(T-&gt;rchild);	//递归遍历右子树</span><br><span class="line">        visit(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void InOrder(BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">    if (T!=NULL)&#123;</span><br><span class="line">        PreOrder(T-&gt;lchild);	//递归遍历左子树</span><br><span class="line">        visit(T);</span><br><span class="line">        PreOrder(T-&gt;rchild);	//递归遍历右子树</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>非递归</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LNR</span><br><span class="line"></span><br><span class="line">左 根 右</span><br><span class="line">当左子树存在时，继续以左为根进行中序，此时左子树的父结点需要入栈保存</span><br><span class="line">栈内结点访问后，需要出栈</span><br></pre></td></tr></table></figure>



<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void LevelOrder(BiTree T)&#123;</span><br><span class="line">	LinkQueue Q;</span><br><span class="line">	InitQueue(Q);</span><br><span class="line">	BiTree p;</span><br><span class="line">	EnQueue(Q,T);</span><br><span class="line">	while(!IsEmpty(Q))&#123;</span><br><span class="line">		DeQueue(Q,p);			//队头结点出队</span><br><span class="line">		visit(p);				//访问出队结点</span><br><span class="line">		if(p-&gt;lchild!=NULL)</span><br><span class="line">			EnQueue(Q,p-&gt;lchild);	//左孩子入队</span><br><span class="line">		if(p-&gt;rchild!=NULL)</span><br><span class="line">			EnQueue(Q,p-&gt;rchild);	//右孩子入队</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="求深度"><a href="#求深度" class="headerlink" title="求深度"></a>求深度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int treeDepth(BiTree T)&#123;</span><br><span class="line">	if(T==NULL)&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		int l=treeDepth(T-&gt;lchild);</span><br><span class="line">		int r=treeDepth(T-&gt;rchild);</span><br><span class="line">		//树的深度=Max(左子树深度，右子树深度)+1</span><br><span class="line">		return l&gt;r?l+1:r+1;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="构造二叉树"><a href="#构造二叉树" class="headerlink" title="构造二叉树"></a>构造二叉树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只给出一棵二叉树的 前/中/后/层 序遍历序列中的一个，不能唯一确定一棵二叉树</span><br></pre></td></tr></table></figure>

<p>但我们可以多种序列来确定二叉树</p>
<h4 id="前序-中序-遍历序列"><a href="#前序-中序-遍历序列" class="headerlink" title="前序+中序 遍历序列"></a>前序+中序 遍历序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">前序的首个结点就是根结点</span><br><span class="line">中序的根节点左边就是左子树结点，右边就是右子树结点</span><br></pre></td></tr></table></figure>



<h4 id="后序-中序-遍历序列"><a href="#后序-中序-遍历序列" class="headerlink" title="后序+中序 遍历序列"></a>后序+中序 遍历序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">后序的尾结点就是根结点</span><br><span class="line">中序的根节点左边就是左子树结点，右边就是右子树结点</span><br></pre></td></tr></table></figure>



<h4 id="层序-中序-遍历序列"><a href="#层序-中序-遍历序列" class="headerlink" title="层序+中序 遍历序列"></a>层序+中序 遍历序列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">层序遍历   根 左子树根 右子树根 左子树的左子树的根 左子树的右子树的根 ...</span><br><span class="line">中序的根节点左边就是左子树结点，右边就是右子树结点</span><br></pre></td></tr></table></figure>



<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>普通二叉树</p>
<ul>
<li>不能从指定节点开始中序遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因为节点指针只指向孩子，无法回溯。</span><br><span class="line">只能从根结点开始遍历</span><br></pre></td></tr></table></figure>

<ul>
<li>不能找到指定节点在中序遍历序列的前驱&#x2F;后继</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">思路：</span><br><span class="line">从根结点进行一次中序遍历，q指针记录当前访问结点，pre指针记录中序遍历时上一个被访问的节点</span><br><span class="line">1. q==指定结点时，pre为前驱</span><br><span class="line">2. pre==指定结点时，q为后继</span><br></pre></td></tr></table></figure>

<p>缺点：不方便，必须从根开始</p>
<p>线索二叉树		方便遍历</p>
<ul>
<li>线索化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n个结点有n+1个空指针，可用来记录遍历序列的前驱、后继信息</span><br><span class="line">而 记录 前驱后继 的指针 称为 “线索”</span><br></pre></td></tr></table></figure>

<ul>
<li>左空子树</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向序列前驱</span><br></pre></td></tr></table></figure>

<ul>
<li>右空子树</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指向序列后继</span><br></pre></td></tr></table></figure>



<p>没有线索的节点怎么找后继？？ 详情见后续</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>定义线索二叉树</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct ThreadNode&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct ThreadNode *lchild,*rchild;</span><br><span class="line">	int ltag,rtag;			//左、右线索 标志 0为孩子，1为线索</span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br></pre></td></tr></table></figure>



<ul>
<li>中序遍历线索化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录指定结点的前驱</span></span><br><span class="line">ThreadNode *pre=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历二叉树，遍历到同时进行线索化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThread</span><span class="params">(ThreadTree T)</span>&#123;	</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;		</span><br><span class="line">		InThread(T-&gt;lchild);	<span class="comment">//中序遍历左子树</span></span><br><span class="line">		visit(T);				<span class="comment">//访问根结点</span></span><br><span class="line">		InThread(T-&gt;rchild);	<span class="comment">//中序遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化过程		</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(ThreadNode *q)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(q-&gt;lchild==<span class="literal">NULL</span>)&#123;	<span class="comment">//左子树为空，则建立前驱线索</span></span><br><span class="line">		q-&gt;lchild=pre;</span><br><span class="line">		q-&gt;ltag=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(pre!=<span class="literal">NULL</span>&amp;&amp;pre-&gt;rchild=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		pre-&gt;rchild=q;		<span class="comment">//建立前驱结点的后继线索(若有的话)</span></span><br><span class="line">		pre-&gt;rtag=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pre=q;		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateInThread</span><span class="params">(ThreadTree T)</span>&#123;</span><br><span class="line">	pre==<span class="literal">NULL</span>;		</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;	<span class="comment">//非空二叉树线索化</span></span><br><span class="line">		InThread(T);</span><br><span class="line">		<span class="keyword">if</span>(pre-&gt;rchild=<span class="literal">NULL</span>)		</span><br><span class="line">			pre-&gt;rtag=<span class="number">1</span>;		<span class="comment">//处理遍历最后一个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首结点的前驱线索为NULL，ltag&#x3D;1;尾结点的后继线索为NUL，rtag&#x3D;1;</p>
<ul>
<li>先序线索化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">唯一不同的:</span><br><span class="line">//先序遍历二叉树，遍历到同时进行线索化</span><br><span class="line">void PreThread(ThreadTree T)&#123;	</span><br><span class="line">	if(T!=NULL)&#123;		</span><br><span class="line">	 	visit(T);				//访问根结点</span><br><span class="line">	 	if(T-&gt;ltag==0)&#123;		</span><br><span class="line">		PreThread(T-&gt;lchild);	//在非线索的情况下，中序遍历左子树</span><br><span class="line">		&#125;</span><br><span class="line">		PreThread(T-&gt;rchild);	//中序遍历右子树</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先序线索化，我们将左空子树 指向 前驱 后，由于会向左继续遍历，所以会向左进入前驱从而进入循环，所以我们需要判断左子树是线索还是子树。</p>
<ul>
<li>后续线索化</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与中序相同</span><br></pre></td></tr></table></figure>



<h4 id="rtag-0找中序后继"><a href="#rtag-0找中序后继" class="headerlink" title="rtag&#x3D;0找中序后继"></a>rtag&#x3D;0找中序后继</h4><ul>
<li>找指定节点p的中序后继   且   p-&gt;rtag&#x3D;0</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找到p结点的p-&gt;rchild子树中第一个中序遍历的结点</span><br><span class="line">LNR		最左是第一个，否则就是根</span><br></pre></td></tr></table></figure>





<ul>
<li>代码实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//找到以p为根(此p是函数参数p)的子树中，第一个被中序遍历的结点</span><br><span class="line">ThreadNode *Firstnode(ThreadNode *p)&#123;</span><br><span class="line">	//循环找到最左下结点（不一定是叶子结点）</span><br><span class="line">	while(p-&gt;ltag==0)	p=p-&gt;lchild;</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在中序线索二叉树中找到结点p的后继节点</span><br><span class="line">ThreadNode *Nextnode(ThreadNode *p)&#123;</span><br><span class="line">	//右子树中最左下结点</span><br><span class="line">	if(p-&gt;rtag==0)	return Firstnode(p-&gt;rchild);</span><br><span class="line">	else	return p-&gt;rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="ltag-0找中序前驱"><a href="#ltag-0找中序前驱" class="headerlink" title="ltag&#x3D;0找中序前驱"></a>ltag&#x3D;0找中序前驱</h4><ul>
<li>找指定结点p的中序前驱 且 p-&gt;ltag&#x3D;0</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找到p结点的p-&gt;lchild子树中最后一个被中序遍历的结点</span><br><span class="line">LNR		最右是最后一个，否则是根</span><br></pre></td></tr></table></figure>

<ul>
<li>代码实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ThreadNode *Lastnode(ThreadNode *p)&#123;</span><br><span class="line">	//循环找最右下节点</span><br><span class="line">	while(p-&gt;rtag=0)	p=p-&gt;rchild;</span><br><span class="line">	return p;		//否则返回根		LNR</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadNode *Prenode(ThreadNode *p)&#123;</span><br><span class="line">	//右子树中最右下结点</span><br><span class="line">	if(p-&gt;rtag==0)	return Lastnode(p-&gt;rchild);</span><br><span class="line">	else	return p-&gt;rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="线索实现非递归中序遍历"><a href="#线索实现非递归中序遍历" class="headerlink" title="线索实现非递归中序遍历"></a>线索实现非递归中序遍历</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Inorder(ThreadNode *T)&#123;</span><br><span class="line">	for(ThreadNode *p=Firstnode(T);p!=NULL;p=Nextnode(p))</span><br><span class="line">		visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="线索实现非递归中序逆遍历"><a href="#线索实现非递归中序逆遍历" class="headerlink" title="线索实现非递归中序逆遍历"></a>线索实现非递归中序逆遍历</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void RevInorder(ThreadNode *T)&#123;</span><br><span class="line">	for(ThreadNode *p=Lastnode(T);p!=NULL;p=Prenode(p))</span><br><span class="line">		visit(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="先序后继"><a href="#先序后继" class="headerlink" title="先序后继"></a>先序后继</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NLR</span><br><span class="line">p有左孩子，后继为p-&gt;lchild</span><br><span class="line">p有右孩子无左孩子，后继为p-&gt;rchild</span><br><span class="line">p有右孩子和左孩子，后继为p-&gt;lchild</span><br></pre></td></tr></table></figure>





<h4 id="先序前驱"><a href="#先序前驱" class="headerlink" title="先序前驱"></a>先序前驱</h4><ul>
<li>要用三叉链表，除非从根开始遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">找指定结点p的前驱</span><br><span class="line">四种情况：</span><br><span class="line">p为其父结点的左孩子		,前驱为 p-&gt;parent</span><br><span class="line">p为其父结点的右孩子，左兄弟非空,前驱为p-&gt;parent-&gt;lchild</span><br><span class="line">p为其父结点的右孩子，左兄弟为空,前驱为p-&gt;parent</span><br><span class="line">p为根，没有前驱,	前驱为NULL</span><br></pre></td></tr></table></figure>



<h4 id="后序前驱"><a href="#后序前驱" class="headerlink" title="后序前驱"></a>后序前驱</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LRN</span><br><span class="line">指定结点有右孩子	前驱为p-&gt;rchild</span><br><span class="line">指定结点没有右孩子	前驱为p-&gt;lchild</span><br></pre></td></tr></table></figure>



<h4 id="后序后继"><a href="#后序后继" class="headerlink" title="后序后继"></a>后序后继</h4><ul>
<li>要用三叉链表，除非从根开始遍历</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p为其父结点的右结点，后继为p-&gt;parent</span><br><span class="line">p为其父结点的左结点，且右兄弟为空，后继为p-&gt;parent</span><br><span class="line">p为其父结点的左结点，且右兄弟非空，后继为p-&gt;parent-&gt;rchild</span><br><span class="line">p是根，没有后继，后继为NULL</span><br></pre></td></tr></table></figure>





<h3 id="树的存储"><a href="#树的存储" class="headerlink" title="树的存储"></a>树的存储</h3><h4 id="双亲表示法-顺序存储"><a href="#双亲表示法-顺序存储" class="headerlink" title="双亲表示法(顺序存储)"></a>双亲表示法(顺序存储)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define MaxSize 100</span><br><span class="line">typedef sturct &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    int parent;		//父结点的下标</span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;	</span><br><span class="line">	PTNode nodes[MaxSize];		</span><br><span class="line">	int n;			//结点数</span><br><span class="line">&#125;PTree;	</span><br><span class="line"></span><br><span class="line">//根节点的parent 为 -1</span><br></pre></td></tr></table></figure>

<p>找孩子，可以利用节点的下标，然后在所有节点中遍历，效率不高。</p>
<ul>
<li>该方法删除节点后，需要将尾结点移动到删除后的空白位置中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提高遍历效率</span><br></pre></td></tr></table></figure>

<ul>
<li>删除结点后，其子树也要被删除，这就要找孩子，需要全局遍历</li>
</ul>
<h4 id="孩子表示法（顺序-链式存储）"><a href="#孩子表示法（顺序-链式存储）" class="headerlink" title="孩子表示法（顺序+链式存储）"></a>孩子表示法（顺序+链式存储）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef struct Node&#123;</span><br><span class="line">    int data;	//存放孩子下标</span><br><span class="line">    struct Node;</span><br><span class="line">&#125;TNode;</span><br><span class="line"></span><br><span class="line">struct PNode &#123;</span><br><span class="line">    T.data;</span><br><span class="line">    int parent;</span><br><span class="line">    TNode *child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct CTNode&#123;</span><br><span class="line">	int child;		//孩子结点的数组下标</span><br><span class="line">	struct CTNode *next;	//下一个孩子</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct CTNode *firstChild;	//第一个孩子</span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	CTBox nodes[MaxSize];</span><br><span class="line">	int n,r;	//结点树和根的位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="孩子兄弟表示法-链式存储"><a href="#孩子兄弟表示法-链式存储" class="headerlink" title="孩子兄弟表示法(链式存储)"></a>孩子兄弟表示法(链式存储)</h4><p>两个指针，一个指向兄弟，一个指向左侧第一个孩子</p>
<p><strong>本质：和二叉链表的存储结构一致（二叉指向两个子结点）</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CSNode&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct CSNode *firstchild,*nextsibling;	</span><br><span class="line">	//第一个孩子(左)和右兄弟指针(右)</span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>

<p>这是一个<strong>树和二叉树</strong>的转化，我们之后就可以利用二叉树操作来处理树</p>
<h4 id="二叉树和森林的转换"><a href="#二叉树和森林的转换" class="headerlink" title="二叉树和森林的转换"></a>二叉树和森林的转换</h4><p>将森林中的每棵树转换为二叉树，之后每棵二叉树的根结点当作兄弟结点</p>
<h3 id="树、森林的遍历"><a href="#树、森林的遍历" class="headerlink" title="树、森林的遍历"></a>树、森林的遍历</h3><h4 id="树的先根遍历"><a href="#树的先根遍历" class="headerlink" title="树的先根遍历"></a>树的先根遍历</h4><ul>
<li>说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若树非空，先访问根结点，再依次对每棵子树进行先根遍历</span><br></pre></td></tr></table></figure>



<ul>
<li>伪代码实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PreOrder(TreeNode *R)&#123;</span><br><span class="line">	if (R!=NULL)&#123;</span><br><span class="line">		visit(R);	//访问根结点</span><br><span class="line">		while(R还有下一个子树T)</span><br><span class="line">			PreOrder(T);	//先根遍历下一棵子树</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体还要考虑定义的树的结构</p>
<ul>
<li>注意</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">等价于树对应的二叉树的先序遍历</span><br></pre></td></tr></table></figure>



<h4 id="树的后根遍历"><a href="#树的后根遍历" class="headerlink" title="树的后根遍历"></a>树的后根遍历</h4><ul>
<li>说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若树非空，先一次对每棵子树进行后根遍历，最后在访问根结点</span><br></pre></td></tr></table></figure>

<ul>
<li>伪代码实现</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PreOrder(TreeNode *R)&#123;</span><br><span class="line">	if (R!=NULL)&#123;</span><br><span class="line">		while(R还有下一个子树T)</span><br><span class="line">			PostOrder(T);	//先根遍历下一棵子树</span><br><span class="line">	 	visit(R);	//访问根结点</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>DFS</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">又称：“深度优先遍历”，即DFS，深度优先搜索</span><br></pre></td></tr></table></figure>

<ul>
<li>注意</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树的后根遍历序列与对应二叉树的中序序列相同</span><br></pre></td></tr></table></figure>



<h4 id="树的层次遍历（队列实现）"><a href="#树的层次遍历（队列实现）" class="headerlink" title="树的层次遍历（队列实现）"></a>树的层次遍历（队列实现）</h4><ul>
<li>说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若树非空，则根结点入队</span><br><span class="line">若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</span><br><span class="line">重复2操作直到队列为空</span><br></pre></td></tr></table></figure>

<ul>
<li>BFS</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">又称：广度优先遍历（即BFS 广度优先搜索）</span><br></pre></td></tr></table></figure>

<h4 id="森林的先序遍历"><a href="#森林的先序遍历" class="headerlink" title="森林的先序遍历"></a>森林的先序遍历</h4><ul>
<li>说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">等效于依次对每个树进行先根遍历</span><br><span class="line">等效于森林转换为二叉树，二叉树进行先序遍历</span><br></pre></td></tr></table></figure>



<h4 id="森林的中序遍历"><a href="#森林的中序遍历" class="headerlink" title="森林的中序遍历"></a>森林的中序遍历</h4><ul>
<li>说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">等效于依次对每个树进行后根遍历</span><br><span class="line">等效于对应二叉树的中序遍历</span><br></pre></td></tr></table></figure>



<h3 id="二叉树建立"><a href="#二叉树建立" class="headerlink" title="二叉树建立"></a>二叉树建立</h3><ul>
<li>给叶子结点的空指针用符号“#”表示</li>
<li>前序遍历序列建立二叉链表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入前序遍历序列,输入“#”代表空结点（空子树）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BiNode *creat(BiTree T)&#123;		//构建一个二叉树</span><br><span class="line">	char ch;</span><br><span class="line">	cin &gt;&gt; ch;</span><br><span class="line">	if(ch==&#x27;#&#x27;)	T=NULL;</span><br><span class="line">	else&#123;</span><br><span class="line">		T=(BiTree)malloc(sizeof(BiNode));</span><br><span class="line">		T-&gt;data=ch;</span><br><span class="line">		T-&gt;lchild=creat(T-&gt;lchild);</span><br><span class="line">		T-&gt;rchild=creat(T-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	return T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>位序为 i 的节点</p>
<ul>
<li>i的左孩子 	—— 2i</li>
<li>i的右孩子        ——2i+1</li>
<li>i的父结点        —— [i&#x2F;2]</li>
<li>i所在的层次    ——[log2(n+1)] 或 [log2 n]+1</li>
</ul>
<h3 id="树和二叉树的对应关系"><a href="#树和二叉树的对应关系" class="headerlink" title="树和二叉树的对应关系"></a>树和二叉树的对应关系</h3><p>树转化为二叉树：</p>
<ul>
<li>同父同级兄弟加线</li>
<li>保留父结点和第一个子结点的连线，删除其他连线，之前加的线不用删。</li>
<li>顺时针转动，层次分明</li>
</ul>
<p>同级兄弟连线为右子树，孩子连线为左子树。</p>
<p><strong>树的后序遍历等价与二叉树的中序遍历</strong> </p>
<h3 id="森林转化为树"><a href="#森林转化为树" class="headerlink" title="森林转化为树"></a>森林转化为树</h3><p>森林中的每棵树转换为二叉树，按照次序将每一棵树的根结点连接，第一棵树的根结点为总树的根</p>
<h3 id="二叉树转化为森林"><a href="#二叉树转化为森林" class="headerlink" title="二叉树转化为森林"></a>二叉树转化为森林</h3><p>二叉树的根结点：</p>
<p>如果有右孩子，一定有森林。</p>
<p>如果没有右孩子，就没有森林</p>
<p>建立树，用递归和非递归实现树的遍历，</p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h3><ul>
<li><code>结点的权</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表示结点的权重，重要性</span><br><span class="line">（或是某种现实含义的值）</span><br></pre></td></tr></table></figure>

<ul>
<li><code>结点的带权路径长度</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积</span><br></pre></td></tr></table></figure>

<ul>
<li><code>树的带权路径长度</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">树中所有叶子结点的带权路径长度之和（WPL），即Weighted Path Length</span><br></pre></td></tr></table></figure>



<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在含有n个带权叶子结点的二叉树中，其中带权路径长度最小的二叉树称为哈夫曼树，也称最优二叉树</span><br></pre></td></tr></table></figure>



<h3 id="哈夫曼树的构造"><a href="#哈夫曼树的构造" class="headerlink" title="哈夫曼树的构造"></a>哈夫曼树的构造</h3><p>给定n个有具体权值的结点，构造哈夫曼树的算法描述如下：</p>
<ul>
<li>组成森林F</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从n个有权值的结点分别作为仅含一个结点的二叉树，构成森林F</span><br></pre></td></tr></table></figure>



<ul>
<li>构造哈夫曼树结点</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将F中选取两棵根结点权值最小的树作为新结点的左右子树，并将左右子树的权值之和赋值给新节点</span><br></pre></td></tr></table></figure>



<ul>
<li>重复步骤</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将之前构建新结点左右子树的两个树，从F中移除，新构建的树移入F中</span><br><span class="line">重复构造哈夫曼树结点的步骤</span><br></pre></td></tr></table></figure>



<p><strong>特性</strong></p>
<ul>
<li><p>每个初始结点最终都成为叶子节点，权值越小的街道那到根结点的路径越大</p>
</li>
<li><p>哈夫曼树的结点总数为<code>2n-1</code></p>
</li>
<li><p>哈夫曼树都不存在度为1的结点</p>
</li>
<li><p>哈夫曼树不唯一，但<code>WPL</code>必然相同且为最优</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当构建哈夫曼结点时，当F中有多个相同权值的根结点树时，我们有多种构建方式</span><br></pre></td></tr></table></figure>







<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>固定长度编码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ASCII编码，8个bit位表示一个字符</span><br><span class="line">一个字节Byte为8个bit</span><br></pre></td></tr></table></figure>

<p>可变长度编码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不同字符允许用不等长的二进制为表示</span><br><span class="line"></span><br><span class="line">若没有一个编码时另一个编码的前缀，则称“前缀编码”	（叶子结点表示字符）</span><br></pre></td></tr></table></figure>



<p>哈夫曼编码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符集中的每个字符作为一个叶子结点，各个字符出现的频度多为结点的权值，根据此来构建哈夫曼树</span><br></pre></td></tr></table></figure>



<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">并查集 是逻辑结构——集合的一种具体实现，</span><br><span class="line">且只进行“并”和&quot;查&quot;两种基本操作</span><br><span class="line"></span><br><span class="line"># 数据元素之间的逻辑关系：集合、线性表、树、图</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">将各个元素划分为若干个互不相交的子集</span><br><span class="line"></span><br><span class="line">两个元素之间的关系有：</span><br><span class="line">属于一个集合</span><br><span class="line">不属于一个集合</span><br></pre></td></tr></table></figure>

<p>回顾</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">森林是m棵互不相交的树的集合</span><br><span class="line"></span><br><span class="line">所以我们可以:</span><br><span class="line">将一个子集的元素，构成一棵树</span><br><span class="line">不同子集代表不同的树，构成森林</span><br></pre></td></tr></table></figure>

<ul>
<li>如何<code>查</code>到一个元素到底属于哪一个集合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从指定元素一路找到树的根结点</span><br><span class="line"></span><br><span class="line">#判断两个元素是否属于同一个集合</span><br><span class="line">查两个元素的树的根结点，判断是否相同</span><br></pre></td></tr></table></figure>

<ul>
<li>把两个集合<code>并</code>为一个集合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让一棵树成为另一棵树的子树</span><br></pre></td></tr></table></figure>



<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查：一路向北，找到根结点</span><br><span class="line">并：一棵树的根的父结点指向另一棵树的根</span><br><span class="line"></span><br><span class="line">采取：双亲表示法 </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>代码实现</p>
<p><code>初始化</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Size 13</span></span><br><span class="line"><span class="type">int</span> UFSets[Size];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Initial</span><span class="params">(<span class="type">int</span> S[])</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Size;i++)&#123;</span><br><span class="line">		S[i]=<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>查 Find</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找第x号元素的集合的根</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(S[x]&gt;=<span class="number">0</span>)</span><br><span class="line">		x=S[x];				<span class="comment">//循环寻找x的根</span></span><br><span class="line">	<span class="keyword">return</span> x;			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>并 Union</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Root==Root2)	<span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//不同集合才能合并</span></span><br><span class="line">	S[Root2]=Root1;			<span class="comment">//将Root2的父结点为Root1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>优化Union</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在每次Union构建树都时候尽可能让树不长太高</span><br><span class="line"></span><br><span class="line">1. 用根结点的绝对值表示该树的结点总数(若树有6个结点，根结点的值赋为-6)</span><br><span class="line">2. Union操作，让小树合并到大树，不能让大树合并到子树上</span><br><span class="line"></span><br><span class="line">合并后，记得将合并树的根赋为两树结点之和</span><br></pre></td></tr></table></figure>

<p><code>优化代码</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Union</span><span class="params">(<span class="type">int</span> S[],<span class="type">int</span> Root1,<span class="type">int</span> Root2)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Root1==Root2) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(S[Root1]&gt;S[Root2])&#123;</span><br><span class="line">		S[Root2]=Root1;</span><br><span class="line">		S[Root1] += S[Root2];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		S[Root1]=Root2;</span><br><span class="line">		S[Root2]+=S[Root1];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>此构建的树高不会超过</code></p>
<p>$|\log_{2}n|+1$</p>
<p>优化此<code>union</code>可以将<code>Find</code>的时间复杂度从$O(n)$优化到$O(log_{2}n)$</p>
<p><code>优化find</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">压缩路径</span><br><span class="line"></span><br><span class="line">将指定结点到根结点的查找路径中的各个结点全部指向根结点</span><br><span class="line">在下一次查找时，我们路过之前的某些结点，会直接找到根结点</span><br></pre></td></tr></table></figure>

<p><code>代码实现</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int Find(int S[],int x)&#123;</span><br><span class="line">	int root=x;</span><br><span class="line">	while(S[root]&gt;=0) root=S[root];	//循环找根</span><br><span class="line">	//此时root就是树的根</span><br><span class="line">	while(x!=root)&#123;			//遍历查找的路径</span><br><span class="line">		int t=S[x];	//记录父结点</span><br><span class="line">		S[x]=root;	//指向root</span><br><span class="line">		x=t;		//遍历到父结点</span><br><span class="line">	&#125;</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度十分接近$O(1)$</p>
<p><code>根本原理</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">让树变矮</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="https://pic.imgdb.cn/item/672b1049d29ded1a8c9f1720.png"><img src="https://pic.imgdb.cn/item/672b1049d29ded1a8c9f1720.png"></a> </p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">tzw</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7--%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/">http://example.com/2025/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_7--%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_6--%E4%B8%B2/" title="数据结构_6--串"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">数据结构_6--串</div></div></a></div><div class="next-post pull-right"><a href="/2025/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_3--%E7%BA%BF%E6%80%A7%E8%A1%A8--%E9%93%BE%E8%A1%A8/" title="数据结构_3--线性表--链表"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">数据结构_3--线性表--链表</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pic.imgdb.cn/item/66deb3ecd9c307b7e9dd4dd9.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">tzw</div><div class="author-info__description">this is memorygo's house</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/memorygo" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#title-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7%E2%80%93%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91date-2024-12-18-16-33-56"><span class="toc-number">1.</span> <span class="toc-text">title: 数据结构_7–树与二叉树date: 2024&#x2F;12&#x2F;18 16:33:56</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number"></span> <span class="toc-text">树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">树的逻辑结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">树的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%A0%91%E3%80%81%E6%97%A0%E5%BA%8F%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97"><span class="toc-number">1.2.</span> <span class="toc-text">有序树、无序树、森林</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.3.</span> <span class="toc-text">树的性质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%80%A7%E8%B4%A81%EF%BC%9A"><span class="toc-number">1.3.1.</span> <span class="toc-text">常见性质1：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%80%A7%E8%B4%A82%EF%BC%9A"><span class="toc-number">1.3.2.</span> <span class="toc-text">常见性质2：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%80%A7%E8%B4%A8-3%EF%BC%9A"><span class="toc-number">1.3.3.</span> <span class="toc-text">常见性质 3：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%80%A7%E8%B4%A8-4%EF%BC%9A"><span class="toc-number">1.3.4.</span> <span class="toc-text">常见性质 4：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%80%A7%E8%B4%A8-5%EF%BC%9A"><span class="toc-number">1.3.5.</span> <span class="toc-text">常见性质 5：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%80%A7%E8%B4%A8-6%EF%BC%9A"><span class="toc-number">1.3.6.</span> <span class="toc-text">常见性质 6：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.</span> <span class="toc-text">树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.1.</span> <span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.2.</span> <span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">1.5.3.</span> <span class="toc-text">二叉排序树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.4.</span> <span class="toc-text">平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.6.</span> <span class="toc-text">二叉树的性质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%80%A7%E8%B4%A81%EF%BC%9A"><span class="toc-number">1.6.1.</span> <span class="toc-text">常用性质1：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%80%A7%E8%B4%A82%EF%BC%9A"><span class="toc-number">1.6.2.</span> <span class="toc-text">常用性质2：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86"><span class="toc-number">1.7.</span> <span class="toc-text">二叉树遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.</span> <span class="toc-text">二叉树顺序存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-number">2.2.</span> <span class="toc-text">二叉链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">2.2.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%8F%89%E9%93%BE%E8%A1%A8"><span class="toc-number">2.3.</span> <span class="toc-text">三叉链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">2.4.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.4.2.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.4.3.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.4.4.</span> <span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E6%B7%B1%E5%BA%A6"><span class="toc-number">2.5.</span> <span class="toc-text">求深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.6.</span> <span class="toc-text">构造二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F-%E4%B8%AD%E5%BA%8F-%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">2.6.1.</span> <span class="toc-text">前序+中序 遍历序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F-%E4%B8%AD%E5%BA%8F-%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">2.6.2.</span> <span class="toc-text">后序+中序 遍历序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F-%E4%B8%AD%E5%BA%8F-%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="toc-number">2.6.3.</span> <span class="toc-text">层序+中序 遍历序列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.7.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.7.1.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rtag-0%E6%89%BE%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="toc-number">2.7.2.</span> <span class="toc-text">rtag&#x3D;0找中序后继</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ltag-0%E6%89%BE%E4%B8%AD%E5%BA%8F%E5%89%8D%E9%A9%B1"><span class="toc-number">2.7.3.</span> <span class="toc-text">ltag&#x3D;0找中序前驱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E5%AE%9E%E7%8E%B0%E9%9D%9E%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.7.4.</span> <span class="toc-text">线索实现非递归中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E5%AE%9E%E7%8E%B0%E9%9D%9E%E9%80%92%E5%BD%92%E4%B8%AD%E5%BA%8F%E9%80%86%E9%81%8D%E5%8E%86"><span class="toc-number">2.7.5.</span> <span class="toc-text">线索实现非递归中序逆遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="toc-number">2.7.6.</span> <span class="toc-text">先序后继</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E5%89%8D%E9%A9%B1"><span class="toc-number">2.7.7.</span> <span class="toc-text">先序前驱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E5%89%8D%E9%A9%B1"><span class="toc-number">2.7.8.</span> <span class="toc-text">后序前驱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E5%90%8E%E7%BB%A7"><span class="toc-number">2.7.9.</span> <span class="toc-text">后序后继</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">2.8.</span> <span class="toc-text">树的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.8.1.</span> <span class="toc-text">双亲表示法(顺序存储)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95%EF%BC%88%E9%A1%BA%E5%BA%8F-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%89"><span class="toc-number">2.8.2.</span> <span class="toc-text">孩子表示法（顺序+链式存储）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A9%E5%AD%90%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.8.3.</span> <span class="toc-text">孩子兄弟表示法(链式存储)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.8.4.</span> <span class="toc-text">二叉树和森林的转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.9.</span> <span class="toc-text">树、森林的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%85%88%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-number">2.9.1.</span> <span class="toc-text">树的先根遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%90%8E%E6%A0%B9%E9%81%8D%E5%8E%86"><span class="toc-number">2.9.2.</span> <span class="toc-text">树的后根遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%88%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%EF%BC%89"><span class="toc-number">2.9.3.</span> <span class="toc-text">树的层次遍历（队列实现）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.9.4.</span> <span class="toc-text">森林的先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.9.5.</span> <span class="toc-text">森林的中序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BB%BA%E7%AB%8B"><span class="toc-number">2.10.</span> <span class="toc-text">二叉树建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">2.11.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">2.12.</span> <span class="toc-text">树和二叉树的对应关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%A0%91"><span class="toc-number">2.13.</span> <span class="toc-text">森林转化为树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%A3%AE%E6%9E%97"><span class="toc-number">2.14.</span> <span class="toc-text">二叉树转化为森林</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%90%8D%E8%AF%8D"><span class="toc-number">3.1.</span> <span class="toc-text">相关名词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">3.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="toc-number">3.3.</span> <span class="toc-text">哈夫曼树的构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">3.4.</span> <span class="toc-text">哈夫曼编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">4.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">逻辑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">存储结构</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/20/shell%E7%BB%83%E4%B9%A0--hexo%E6%B7%BB%E5%8A%A0front-matter/" title="shell练习--hexo添加front-matter">shell练习--hexo添加front-matter</a><time datetime="2025-03-20T04:05:37.000Z" title="Created 2025-03-20 12:05:37">2025-03-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_T2--%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8/" title="数据结构_T2--矩阵的压缩存储">数据结构_T2--矩阵的压缩存储</a><time datetime="2025-03-11T07:36:46.000Z" title="Created 2025-03-11 15:36:46">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_8--%E5%9B%BE/" title="数据结构_8--图">数据结构_8--图</a><time datetime="2025-03-11T07:36:45.000Z" title="Created 2025-03-11 15:36:45">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_9--%E6%9F%A5%E6%89%BE/" title="数据结构_9--查找">数据结构_9--查找</a><time datetime="2025-03-11T07:36:45.000Z" title="Created 2025-03-11 15:36:45">2025-03-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84_T1--%E5%BC%95%E5%AD%90/" title="数据结构_T1--引子">数据结构_T1--引子</a><time datetime="2025-03-11T07:36:45.000Z" title="Created 2025-03-11 15:36:45">2025-03-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By tzw</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>